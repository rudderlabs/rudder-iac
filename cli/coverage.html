
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>rudder-cli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rudderlabs/rudder-iac/cli/cmd/rudder-cli/main.go (0.0%)</option>
				
				<option value="file1">github.com/rudderlabs/rudder-iac/cli/internal/app/dependencies.go (0.0%)</option>
				
				<option value="file2">github.com/rudderlabs/rudder-iac/cli/internal/auth/accesstoken.go (0.0%)</option>
				
				<option value="file3">github.com/rudderlabs/rudder-iac/cli/internal/cmd/auth.go (0.0%)</option>
				
				<option value="file4">github.com/rudderlabs/rudder-iac/cli/internal/cmd/debug.go (0.0%)</option>
				
				<option value="file5">github.com/rudderlabs/rudder-iac/cli/internal/cmd/root.go (0.0%)</option>
				
				<option value="file6">github.com/rudderlabs/rudder-iac/cli/internal/cmd/schema/convert.go (77.4%)</option>
				
				<option value="file7">github.com/rudderlabs/rudder-iac/cli/internal/cmd/schema/fetch.go (62.5%)</option>
				
				<option value="file8">github.com/rudderlabs/rudder-iac/cli/internal/cmd/schema/schema.go (0.0%)</option>
				
				<option value="file9">github.com/rudderlabs/rudder-iac/cli/internal/cmd/schema/unflatten.go (82.6%)</option>
				
				<option value="file10">github.com/rudderlabs/rudder-iac/cli/internal/cmd/telemetry/telemetry.go (0.0%)</option>
				
				<option value="file11">github.com/rudderlabs/rudder-iac/cli/internal/cmd/telemetry/utils.go (0.0%)</option>
				
				<option value="file12">github.com/rudderlabs/rudder-iac/cli/internal/cmd/trackingplan/apply/apply.go (0.0%)</option>
				
				<option value="file13">github.com/rudderlabs/rudder-iac/cli/internal/cmd/trackingplan/destroy/destroy.go (0.0%)</option>
				
				<option value="file14">github.com/rudderlabs/rudder-iac/cli/internal/cmd/trackingplan/trackingplan.go (0.0%)</option>
				
				<option value="file15">github.com/rudderlabs/rudder-iac/cli/internal/cmd/trackingplan/validate/validate.go (0.0%)</option>
				
				<option value="file16">github.com/rudderlabs/rudder-iac/cli/internal/config/config.go (0.0%)</option>
				
				<option value="file17">github.com/rudderlabs/rudder-iac/cli/internal/project/loader/loader.go (92.0%)</option>
				
				<option value="file18">github.com/rudderlabs/rudder-iac/cli/internal/project/project.go (100.0%)</option>
				
				<option value="file19">github.com/rudderlabs/rudder-iac/cli/internal/project/specs/spec.go (92.3%)</option>
				
				<option value="file20">github.com/rudderlabs/rudder-iac/cli/internal/providers/composite.go (98.4%)</option>
				
				<option value="file21">github.com/rudderlabs/rudder-iac/cli/internal/providers/datacatalog/provider.go (0.0%)</option>
				
				<option value="file22">github.com/rudderlabs/rudder-iac/cli/internal/providers/retl/model.go (0.0%)</option>
				
				<option value="file23">github.com/rudderlabs/rudder-iac/cli/internal/providers/retl/provider.go (0.0%)</option>
				
				<option value="file24">github.com/rudderlabs/rudder-iac/cli/internal/schema/config/config.go (100.0%)</option>
				
				<option value="file25">github.com/rudderlabs/rudder-iac/cli/internal/schema/converter/analyzer.go (68.5%)</option>
				
				<option value="file26">github.com/rudderlabs/rudder-iac/cli/internal/schema/converter/converter.go (50.8%)</option>
				
				<option value="file27">github.com/rudderlabs/rudder-iac/cli/internal/schema/converter/generators.go (95.1%)</option>
				
				<option value="file28">github.com/rudderlabs/rudder-iac/cli/internal/schema/unflatten/unflatten.go (88.1%)</option>
				
				<option value="file29">github.com/rudderlabs/rudder-iac/cli/internal/syncer/differ/diff.go (56.7%)</option>
				
				<option value="file30">github.com/rudderlabs/rudder-iac/cli/internal/syncer/differ/printer.go (0.0%)</option>
				
				<option value="file31">github.com/rudderlabs/rudder-iac/cli/internal/syncer/planner/planner.go (86.0%)</option>
				
				<option value="file32">github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources/graph.go (95.2%)</option>
				
				<option value="file33">github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources/references.go (92.3%)</option>
				
				<option value="file34">github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources/resource.go (57.1%)</option>
				
				<option value="file35">github.com/rudderlabs/rudder-iac/cli/internal/syncer/state/errors.go (100.0%)</option>
				
				<option value="file36">github.com/rudderlabs/rudder-iac/cli/internal/syncer/state/serializer.go (98.1%)</option>
				
				<option value="file37">github.com/rudderlabs/rudder-iac/cli/internal/syncer/state/state.go (84.4%)</option>
				
				<option value="file38">github.com/rudderlabs/rudder-iac/cli/internal/syncer/syncer.go (56.2%)</option>
				
				<option value="file39">github.com/rudderlabs/rudder-iac/cli/internal/telemetry/logger.go (0.0%)</option>
				
				<option value="file40">github.com/rudderlabs/rudder-iac/cli/internal/telemetry/telemetry.go (0.0%)</option>
				
				<option value="file41">github.com/rudderlabs/rudder-iac/cli/internal/testutils/mockprovider.go (0.0%)</option>
				
				<option value="file42">github.com/rudderlabs/rudder-iac/cli/internal/testutils/mockresources.go (0.0%)</option>
				
				<option value="file43">github.com/rudderlabs/rudder-iac/cli/internal/ui/ask.go (0.0%)</option>
				
				<option value="file44">github.com/rudderlabs/rudder-iac/cli/internal/ui/errors.go (0.0%)</option>
				
				<option value="file45">github.com/rudderlabs/rudder-iac/cli/internal/ui/spinner.go (0.0%)</option>
				
				<option value="file46">github.com/rudderlabs/rudder-iac/cli/internal/ui/styles.go (0.0%)</option>
				
				<option value="file47">github.com/rudderlabs/rudder-iac/cli/pkg/localcatalog/catalog.go (27.3%)</option>
				
				<option value="file48">github.com/rudderlabs/rudder-iac/cli/pkg/localcatalog/model.go (75.0%)</option>
				
				<option value="file49">github.com/rudderlabs/rudder-iac/cli/pkg/localcatalog/tracking_plan.go (8.2%)</option>
				
				<option value="file50">github.com/rudderlabs/rudder-iac/cli/pkg/logger/log.go (0.0%)</option>
				
				<option value="file51">github.com/rudderlabs/rudder-iac/cli/pkg/provider/catalog.go (0.0%)</option>
				
				<option value="file52">github.com/rudderlabs/rudder-iac/cli/pkg/provider/customtype.go (0.0%)</option>
				
				<option value="file53">github.com/rudderlabs/rudder-iac/cli/pkg/provider/event.go (88.9%)</option>
				
				<option value="file54">github.com/rudderlabs/rudder-iac/cli/pkg/provider/property.go (88.5%)</option>
				
				<option value="file55">github.com/rudderlabs/rudder-iac/cli/pkg/provider/state/customtype.go (62.3%)</option>
				
				<option value="file56">github.com/rudderlabs/rudder-iac/cli/pkg/provider/state/event.go (100.0%)</option>
				
				<option value="file57">github.com/rudderlabs/rudder-iac/cli/pkg/provider/state/property.go (91.9%)</option>
				
				<option value="file58">github.com/rudderlabs/rudder-iac/cli/pkg/provider/state/trackingplan.go (38.1%)</option>
				
				<option value="file59">github.com/rudderlabs/rudder-iac/cli/pkg/provider/state/types.go (57.7%)</option>
				
				<option value="file60">github.com/rudderlabs/rudder-iac/cli/pkg/provider/testutils/factory/trackingplan_client.go (0.0%)</option>
				
				<option value="file61">github.com/rudderlabs/rudder-iac/cli/pkg/provider/testutils/factory/trackingplan_state.go (0.0%)</option>
				
				<option value="file62">github.com/rudderlabs/rudder-iac/cli/pkg/provider/trackingplan.go (83.1%)</option>
				
				<option value="file63">github.com/rudderlabs/rudder-iac/cli/pkg/schema/client/schema_client.go (94.4%)</option>
				
				<option value="file64">github.com/rudderlabs/rudder-iac/cli/pkg/schema/utils/file.go (0.0%)</option>
				
				<option value="file65">github.com/rudderlabs/rudder-iac/cli/pkg/validate/duplicate_keys.go (40.0%)</option>
				
				<option value="file66">github.com/rudderlabs/rudder-iac/cli/pkg/validate/refs.go (57.7%)</option>
				
				<option value="file67">github.com/rudderlabs/rudder-iac/cli/pkg/validate/required_keys.go (59.7%)</option>
				
				<option value="file68">github.com/rudderlabs/rudder-iac/cli/pkg/validate/validate.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import "github.com/rudderlabs/rudder-iac/cli/internal/cmd"

var version string = "0.0.0"

func main() <span class="cov0" title="0">{
        cmd.SetVersion(version)
        cmd.Execute()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "fmt"

        "github.com/rudderlabs/rudder-iac/api/client"
        "github.com/rudderlabs/rudder-iac/api/client/catalog"
        "github.com/rudderlabs/rudder-iac/cli/internal/config"
        "github.com/rudderlabs/rudder-iac/cli/internal/project"
        "github.com/rudderlabs/rudder-iac/cli/internal/providers"
        "github.com/rudderlabs/rudder-iac/cli/internal/providers/datacatalog"
        "github.com/rudderlabs/rudder-iac/cli/internal/providers/retl"
)

var (
        v string
)

type Providers struct {
        DataCatalog project.Provider
        RETL        project.Provider
}

type deps struct {
        client            *client.Client
        providers         *Providers
        compositeProvider project.Provider
}

type Deps interface {
        Client() *client.Client
        Providers() *Providers
        CompositeProvider() project.Provider
}

func Initialise(version string) <span class="cov0" title="0">{
        v = version
}</span>

func validateDependencies() error <span class="cov0" title="0">{
        cfg := config.GetConfig()
        if cfg.Auth.AccessToken == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("access token is required, please run `rudder-cli auth login`, or set the access token via the RUDDERSTACK_ACCESS_TOKEN environment variable")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func NewDeps() (Deps, error) <span class="cov0" title="0">{
        if err := validateDependencies(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c, err := setupClient(v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("setup client: %w", err)
        }</span>

        <span class="cov0" title="0">p := setupProviders(c)

        cp, err := providers.NewCompositeProvider(p.DataCatalog, p.RETL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize composite provider: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;deps{
                client:            c,
                providers:         p,
                compositeProvider: cp,
        }, nil</span>
}

func setupClient(version string) (*client.Client, error) <span class="cov0" title="0">{
        cfg := config.GetConfig()
        return client.New(
                cfg.Auth.AccessToken,
                client.WithBaseURL(cfg.APIURL),
                client.WithUserAgent("rudder-cli/"+version),
        )
}</span>

func setupProviders(c *client.Client) *Providers <span class="cov0" title="0">{
        dcp := datacatalog.New(catalog.NewRudderDataCatalog(c))
        retlp := retl.New()

        return &amp;Providers{
                DataCatalog: dcp,
                RETL:        retlp,
        }
}</span>

func (d *deps) Client() *client.Client <span class="cov0" title="0">{
        return d.client
}</span>

func (d *deps) Providers() *Providers <span class="cov0" title="0">{
        return d.providers
}</span>

func (d *deps) CompositeProvider() project.Provider <span class="cov0" title="0">{
        return d.compositeProvider
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package auth

import (
        "fmt"

        "github.com/rudderlabs/rudder-iac/cli/internal/config"
        "github.com/rudderlabs/rudder-iac/cli/internal/ui"
)

func Login() error <span class="cov0" title="0">{
        accessToken, err := ui.AskSecret("Enter your access token:")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading access token: %w", err)
        }</span>

        <span class="cov0" title="0">config.SetAccessToken(accessToken)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "github.com/rudderlabs/rudder-iac/cli/internal/auth"
        "github.com/rudderlabs/rudder-iac/cli/internal/cmd/telemetry"
        "github.com/spf13/cobra"
)

func init() <span class="cov0" title="0">{
        authCmd.AddCommand(loginCmd)
}</span>

var authCmd = &amp;cobra.Command{
        Use:   "auth",
        Short: "Authentication commands",
}

var loginCmd = &amp;cobra.Command{
        Use:   "login",
        Short: "Login with an access token",
        Args:  cobra.NoArgs,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                var err error

                defer func() </span><span class="cov0" title="0">{
                        telemetry.TrackCommand("auth login", err)
                }</span>()

                <span class="cov0" title="0">err = auth.Login()
                return err</span>
        },
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"

        "github.com/rudderlabs/rudder-iac/cli/internal/config"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

func init() <span class="cov0" title="0">{
        debugCmd.AddCommand(configCmd)
        debugCmd.AddCommand(configFileCmd)
}</span>

var debugCmd = &amp;cobra.Command{
        Use:    "debug",
        Short:  "Debug commands",
        Hidden: true,
        PersistentPreRunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if !viper.GetBool("debug") </span><span class="cov0" title="0">{
                        return fmt.Errorf("debug commands are disabled")
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
}

var configCmd = &amp;cobra.Command{
        Use:   "config",
        Short: "Dump the active configuration",
        Args:  cobra.NoArgs,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                cfg := config.GetConfig()
                configJSON, err := json.MarshalIndent(cfg, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">fmt.Println(string(configJSON))
                return nil</span>
        },
}

var configFileCmd = &amp;cobra.Command{
        Use:   "config-file",
        Short: "Print the path to the active configuration file",
        Args:  cobra.NoArgs,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println(viper.ConfigFileUsed())
        }</span>,
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
        "fmt"
        "log/slog"
        "os"
        "runtime/debug"

        "github.com/kyokomi/emoji/v2"
        "github.com/rudderlabs/rudder-iac/cli/internal/app"
        "github.com/rudderlabs/rudder-iac/cli/internal/cmd/schema"
        telemetryCmd "github.com/rudderlabs/rudder-iac/cli/internal/cmd/telemetry"
        "github.com/rudderlabs/rudder-iac/cli/internal/cmd/trackingplan"
        "github.com/rudderlabs/rudder-iac/cli/internal/config"
        "github.com/rudderlabs/rudder-iac/cli/internal/telemetry"
        "github.com/rudderlabs/rudder-iac/cli/internal/ui"
        "github.com/rudderlabs/rudder-iac/cli/pkg/logger"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var (
        cfgFile string
        log     = logger.New("root")
)

func recovery() <span class="cov0" title="0">{
        if r := recover(); r != nil </span><span class="cov0" title="0">{
                fmt.Println(emoji.Sprintf("\n:skull:Oops! Unexpected error occurred. Please contact tech support.\n"))
                log.Error("panic detected", "error", r)
                log.Error(string(debug.Stack()))

                os.Exit(1)
        }</span>
}

func init() <span class="cov0" title="0">{
        cobra.OnInitialize(initConfig)
        cobra.OnInitialize(initLogger)
        cobra.OnInitialize(initAppDependencies)
        cobra.OnInitialize(initTelemetry)

        rootCmd.PersistentFlags().StringVarP(
                &amp;cfgFile,
                "config",
                "c",
                config.DefaultConfigFile(),
                fmt.Sprintf("config file (default is '%s')", config.DefaultConfigFile()),
        )

        // Add subcommands to the root command
        rootCmd.AddCommand(authCmd)
        rootCmd.AddCommand(debugCmd)
        rootCmd.AddCommand(schema.NewCmdSchema())
        rootCmd.AddCommand(trackingplan.NewCmdTrackingPlan())
        rootCmd.AddCommand(telemetryCmd.NewCmdTelemetry())
}</span>

func initConfig() <span class="cov0" title="0">{
        config.InitConfig(cfgFile)

        // only add debug command if enabled in config
        if viper.GetBool("debug") </span><span class="cov0" title="0">{
                debugCmd.Hidden = false
        }</span>

}

func initLogger() <span class="cov0" title="0">{
        if viper.GetBool("debug") </span><span class="cov0" title="0">{
                logger.SetLogLevel(slog.LevelDebug)
        }</span>
}

func initAppDependencies() <span class="cov0" title="0">{
        app.Initialise(rootCmd.Version)
}</span>

func initTelemetry() <span class="cov0" title="0">{
        telemetry.Initialise(rootCmd.Version)
}</span>

func SetVersion(v string) <span class="cov0" title="0">{
        rootCmd.Version = v
}</span>

var rootCmd = &amp;cobra.Command{
        Use:           "rudder-cli",
        Short:         "Rudder CLI",
        Long:          `Rudder is a CLI tool for managing your projects.`,
        SilenceUsage:  true,
        SilenceErrors: true, // We will handle errors directly in Execute
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                cmd.Help()
        }</span>,
}

func Execute() <span class="cov0" title="0">{
        defer recovery()

        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                ui.ShowError(err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package schema

import (
        "fmt"

        "github.com/rudderlabs/rudder-iac/cli/internal/schema/converter"
        "github.com/spf13/cobra"
)

// NewCmdConvert creates the convert command
func NewCmdConvert() *cobra.Command <span class="cov0" title="0">{
        var (
                dryRun  bool
                verbose bool
                indent  int
        )

        cmd := &amp;cobra.Command{
                Use:   "convert [input-file] [output-dir]",
                Short: "Convert unflattened schemas to YAML files",
                Long: `Convert unflattened schemas to RudderStack Data Catalog YAML files.

This command takes an unflattened schemas JSON file as input and generates:
- events.yaml: All unique events extracted from eventIdentifier
- properties.yaml: All properties with custom type references
- custom-types.yaml: Custom object and array types
- tracking-plans/: Individual tracking plans grouped by writeKey

The generated YAML files follow the RudderStack Data Catalog specifications
and can be used with rudder-cli for tracking plan management.

Examples:
  rudder-cli schema convert schemas.json output/
  rudder-cli schema convert schemas.json output/ --verbose --dry-run`,
                Args: cobra.ExactArgs(2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runConvert(args[0], args[1], dryRun, verbose, indent)
                }</span>,
        }

        // Add flags for the convert command
        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show what would be generated without writing files")
        cmd.Flags().BoolVarP(&amp;verbose, "verbose", "v", false, "Enable verbose output")
        cmd.Flags().IntVar(&amp;indent, "indent", 2, "Number of spaces for YAML indentation")

        return cmd</span>
}

// runConvert handles the convert command execution
func runConvert(inputFile, outputDir string, dryRun, verbose bool, indent int) error <span class="cov8" title="1">{
        if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Converting schemas from %s to %s...\n", inputFile, outputDir)
        }</span>

        // Create conversion options
        <span class="cov8" title="1">options := converter.ConversionOptions{
                InputFile:  inputFile,
                OutputDir:  outputDir,
                DryRun:     dryRun,
                Verbose:    verbose,
                YAMLIndent: indent,
        }

        // Create converter and run conversion
        schemaConverter := converter.NewSchemaConverter(options)
        result, err := schemaConverter.Convert()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("conversion failed: %w", err)
        }</span>

        // Display results
        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("\nDRY RUN SUMMARY:\n")
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("\nCONVERSION COMPLETED SUCCESSFULLY!\n")
        }</span>

        <span class="cov8" title="1">fmt.Printf("📊 Statistics:\n")
        fmt.Printf("  Events: %d\n", result.EventsCount)
        fmt.Printf("  Properties: %d\n", result.PropertiesCount)
        fmt.Printf("  Custom Types: %d\n", result.CustomTypesCount)
        fmt.Printf("  Tracking Plans: %d\n", len(result.TrackingPlans))

        if !dryRun </span><span class="cov8" title="1">{
                fmt.Printf("\n📁 Generated Files:\n")
                for _, file := range result.GeneratedFiles </span><span class="cov8" title="1">{
                        fmt.Printf("  ✓ %s\n", file)
                }</span>

                <span class="cov8" title="1">fmt.Printf("\n🎯 Next Steps:\n")
                fmt.Printf("  1. Review the generated YAML files\n")
                fmt.Printf("  2. Validate with: rudder-cli tp validate -l %s\n", outputDir)
                fmt.Printf("  3. Deploy with: rudder-cli tp apply -l %s\n", outputDir)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package schema

import (
        "encoding/json"
        "fmt"
        "os"

        "github.com/rudderlabs/rudder-iac/cli/internal/schema/config"
        "github.com/rudderlabs/rudder-iac/cli/pkg/schema/client"
        pkgModels "github.com/rudderlabs/rudder-iac/cli/pkg/schema/models"
        "github.com/spf13/cobra"
)

// NewCmdFetch creates the fetch command
func NewCmdFetch() *cobra.Command <span class="cov0" title="0">{
        var (
                writeKey string
                dryRun   bool
                verbose  bool
                indent   int
        )

        cmd := &amp;cobra.Command{
                Use:   "fetch [output-file]",
                Short: "Fetch event schemas from the API",
                Long: `Fetch event schemas from the Event Audit API and save them to a JSON file.
The output file will have the same structure as schemas_real.json.

Authentication and Configuration:
- Uses the main CLI's authentication system
- Access token: Set via 'rudder-cli auth login' or RUDDERSTACK_ACCESS_TOKEN environment variable
- API URL: Set via RUDDERSTACK_API_URL environment variable (defaults to RudderStack API)

Examples:
  rudder-cli schema fetch schemas.json
  rudder-cli schema fetch schemas.json --write-key=YOUR_WRITE_KEY
  rudder-cli schema fetch schemas.json --verbose --dry-run`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runFetch(args[0], writeKey, dryRun, verbose, indent)
                }</span>,
        }

        // Add flags for the fetch command
        <span class="cov0" title="0">cmd.Flags().StringVar(&amp;writeKey, "write-key", "", "Filter schemas by write key (source)")
        cmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show what would be done without writing output file")
        cmd.Flags().BoolVarP(&amp;verbose, "verbose", "v", false, "Enable verbose output")
        cmd.Flags().IntVar(&amp;indent, "indent", 2, "Number of spaces for JSON indentation")

        return cmd</span>
}

// runFetch handles the fetch command execution
func runFetch(outputFile, writeKey string, dryRun, verbose bool, indent int) error <span class="cov8" title="1">{
        if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Fetching schemas from API...\n")
        }</span>

        // Load configuration from environment variables
        <span class="cov8" title="1">cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("configuration error: %w", err)
        }</span>

        <span class="cov8" title="1">if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Using API URL: %s\n", cfg.APIURL)
                if writeKey != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Filtering by write key: %s\n", writeKey)
                }</span>
        }

        // Create API client
        <span class="cov8" title="1">apiClient := client.NewSchemaClient(cfg.APIURL, cfg.APIToken)

        // Fetch schemas
        schemas, err := apiClient.FetchAllSchemas(writeKey)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to fetch schemas: %w", err)
        }</span>

        <span class="cov8" title="1">if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Successfully fetched %d schemas\n", len(schemas))
        }</span>

        // Create output structure
        <span class="cov8" title="1">output := pkgModels.SchemasFile{
                Schemas: schemas,
        }

        if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("DRY RUN: Would write %d schemas to %s\n", len(schemas), outputFile)
                if verbose &amp;&amp; len(schemas) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("DRY RUN: First schema preview:\n")
                        fmt.Printf("  UID: %s\n", schemas[0].UID)
                        fmt.Printf("  Event: %s\n", schemas[0].EventIdentifier)
                        fmt.Printf("  Write Key: %s\n", schemas[0].WriteKey)
                        fmt.Printf("  Schema fields count: %d\n", len(schemas[0].Schema))
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // Write output file
        <span class="cov8" title="1">if err := writeJSONFile(outputFile, output, indent); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write output file: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("✓ Successfully fetched %d schemas\n", len(schemas))
        fmt.Printf("✓ Output written to %s\n", outputFile)

        return nil</span>
}

// writeJSONFile writes the schemas to a JSON file with proper indentation
func writeJSONFile(filename string, data interface{}, indent int) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        encoder := json.NewEncoder(file)
        if indent &gt; 0 </span><span class="cov8" title="1">{
                encoder.SetIndent("", fmt.Sprintf("%*s", indent, ""))
        }</span>

        <span class="cov8" title="1">if err := encoder.Encode(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode JSON: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package schema

import (
        "fmt"

        "github.com/MakeNowJust/heredoc/v2"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

func NewCmdSchema() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "schema &lt;command&gt;",
                Short: "Manage event schemas and data catalog resources",
                Long:  "Manage the lifecycle of event schemas and data catalog resources using RudderStack Event Audit API",
                Example: heredoc.Doc(`
                        $ rudder-cli schema fetch schemas.json
                        $ rudder-cli schema unflatten input.json output.json
                        $ rudder-cli schema convert schemas.json output/
                `),
                PersistentPreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if !viper.GetBool("experimental") </span><span class="cov0" title="0">{
                                return fmt.Errorf("schema commands require experimental mode. Set RUDDERSTACK_CLI_EXPERIMENTAL=true or add \"experimental\": true to your config file")
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
        }

        // Add subcommands
        <span class="cov0" title="0">cmd.AddCommand(NewCmdFetch())
        cmd.AddCommand(NewCmdUnflatten())
        cmd.AddCommand(NewCmdConvert())

        return cmd</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package schema

import (
        "fmt"

        "github.com/rudderlabs/rudder-iac/cli/internal/schema/unflatten"
        "github.com/rudderlabs/rudder-iac/cli/pkg/schema/utils"
        "github.com/spf13/cobra"
)

// NewCmdUnflatten creates the unflatten command
func NewCmdUnflatten() *cobra.Command <span class="cov0" title="0">{
        var (
                dryRun  bool
                verbose bool
                indent  int
        )

        cmd := &amp;cobra.Command{
                Use:   "unflatten [input-file] [output-file]",
                Short: "Unflatten schema JSON files",
                Long: `Unflatten converts flattened schema keys back to nested JSON structures.
Input file should contain schemas with flattened keys using dot notation.
Output file will contain the same schemas with properly nested structures.

Examples:
  rudder-cli schema unflatten input.json output.json
  rudder-cli schema unflatten input.json output.json --verbose --dry-run`,
                Args: cobra.ExactArgs(2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runUnflatten(args[0], args[1], dryRun, verbose, indent)
                }</span>,
        }

        // Add flags for the unflatten command
        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show what would be done without writing output file")
        cmd.Flags().BoolVarP(&amp;verbose, "verbose", "v", false, "Enable verbose output")
        cmd.Flags().IntVar(&amp;indent, "indent", 2, "Number of spaces for JSON indentation")

        return cmd</span>
}

// runUnflatten handles the unflatten command execution
func runUnflatten(inputFile, outputFile string, dryRun, verbose bool, indent int) error <span class="cov8" title="1">{
        if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Processing %s...\n", inputFile)
        }</span>

        // Check if input file exists
        <span class="cov8" title="1">if !utils.FileExists(inputFile) </span><span class="cov8" title="1">{
                return fmt.Errorf("input file %s does not exist", inputFile)
        }</span>

        // Read the input file
        <span class="cov8" title="1">schemasFile, err := utils.ReadSchemasFile(inputFile)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to read input file: %w", err)
        }</span>

        <span class="cov8" title="1">if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Found %d schemas to unflatten\n", len(schemasFile.Schemas))
        }</span>

        // Process each schema
        <span class="cov8" title="1">processedCount := 0
        for i := range schemasFile.Schemas </span><span class="cov8" title="1">{
                if len(schemasFile.Schemas[i].Schema) &gt; 0 </span><span class="cov8" title="1">{
                        schemasFile.Schemas[i].Schema = unflatten.UnflattenSchema(schemasFile.Schemas[i].Schema)
                        processedCount++
                }</span>
        }

        <span class="cov8" title="1">if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Successfully unflattened %d schemas\n", processedCount)
        }</span>

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("DRY RUN: Would write output to %s\n", outputFile)
                if verbose </span><span class="cov8" title="1">{
                        fmt.Printf("DRY RUN: First schema preview:\n")
                        if len(schemasFile.Schemas) &gt; 0 </span><span class="cov8" title="1">{
                                fmt.Printf("  Event: %s\n", schemasFile.Schemas[0].EventIdentifier)
                                fmt.Printf("  Schema keys count: %d\n", countKeys(schemasFile.Schemas[0].Schema))
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }

        // Write the output file
        <span class="cov8" title="1">if err := utils.WriteSchemasFile(outputFile, schemasFile, indent); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write output file: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("✓ Successfully unflattened %d schemas\n", processedCount)
        fmt.Printf("✓ Output written to %s\n", outputFile)

        return nil</span>
}

// countKeys recursively counts the number of keys in a nested structure
func countKeys(obj interface{}) int <span class="cov8" title="1">{
        switch v := obj.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                count := 0
                for _, value := range v </span><span class="cov8" title="1">{
                        count += 1 + countKeys(value)
                }</span>
                <span class="cov8" title="1">return count</span>
        case []interface{}:<span class="cov8" title="1">
                count := 0
                for _, value := range v </span><span class="cov8" title="1">{
                        count += countKeys(value)
                }</span>
                <span class="cov8" title="1">return count</span>
        default:<span class="cov8" title="1">
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package telemetry

import (
        "fmt"

        "github.com/MakeNowJust/heredoc/v2"
        "github.com/rudderlabs/rudder-iac/cli/internal/config"
        "github.com/rudderlabs/rudder-iac/cli/internal/telemetry"
        "github.com/rudderlabs/rudder-iac/cli/pkg/logger"
        "github.com/spf13/cobra"
)

var log = logger.New("telemetry")

var telemetryCmd = &amp;cobra.Command{
        Use:   "telemetry",
        Short: "Manage telemetry settings",
        Long: heredoc.Doc(`
                Manage telemetry settings for the CLI.
                
                Telemetry helps us understand how the CLI is being used and helps us improve it.
                No sensitive information is collected. The data collected includes:
                - Command usage statistics
                - Error occurrences (without sensitive details)
                - Basic system information
                
                Use 'status' to check current telemetry settings
                Use 'enable' or 'disable' to modify telemetry collection
        `),
}

var telemetryEnableCmd = &amp;cobra.Command{
        Use:   "enable",
        Short: "Enable telemetry",
        Long:  "Enable telemetry collection to help improve the CLI",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                telemetry.EnableTelemetry()
                log.Info("telemetry has been enabled")
                return nil
        }</span>,
}

var telemetryDisableCmd = &amp;cobra.Command{
        Use:   "disable",
        Short: "Disable telemetry",
        Long:  "Disable telemetry collection",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                telemetry.DisableTelemetry()
                log.Info("telemetry has been disabled")
                return nil
        }</span>,
}

var telemetryStatusCmd = &amp;cobra.Command{
        Use:   "status",
        Short: "Show current telemetry status",
        Long:  "Display whether telemetry collection is currently enabled or disabled",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                status := "enabled"

                if config.GetConfig().Telemetry.Disabled </span><span class="cov0" title="0">{
                        status = "disabled"
                }</span>

                <span class="cov0" title="0">fmt.Printf("telemetry is currently %s\n", status)
                return nil</span>
        },
}

func NewCmdTelemetry() *cobra.Command <span class="cov0" title="0">{
        telemetryCmd.AddCommand(telemetryEnableCmd)
        telemetryCmd.AddCommand(telemetryDisableCmd)
        telemetryCmd.AddCommand(telemetryStatusCmd)

        return telemetryCmd
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package telemetry

import "github.com/rudderlabs/rudder-iac/cli/internal/telemetry"

const (
        CommandExecutedEvent = "CLI Command Executed"
)

type KV struct {
        K string
        V interface{}
}

func TrackCommand(command string, err error, extras ...KV) <span class="cov0" title="0">{

        props := map[string]interface{}{
                "command": command,
                "errored": err != nil,
        }

        for _, extra := range extras </span><span class="cov0" title="0">{
                props[extra.K] = extra.V
        }</span>

        <span class="cov0" title="0">if err := telemetry.TrackEvent(CommandExecutedEvent, props); err != nil </span><span class="cov0" title="0">{
                log.Error("failed to track command", "error", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package apply

import (
        "context"
        "fmt"

        "github.com/MakeNowJust/heredoc/v2"
        "github.com/rudderlabs/rudder-iac/cli/internal/app"
        "github.com/rudderlabs/rudder-iac/cli/internal/cmd/telemetry"
        "github.com/rudderlabs/rudder-iac/cli/internal/project"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer"
        "github.com/rudderlabs/rudder-iac/cli/pkg/logger"
        "github.com/spf13/cobra"
)

var (
        log = logger.New("trackingplan.apply")
)

func NewCmdTPApply() *cobra.Command <span class="cov0" title="0">{
        var (
                deps     app.Deps
                p        project.Project
                err      error
                location string
                dryRun   bool
                confirm  bool
        )

        cmd := &amp;cobra.Command{
                Use:   "apply",
                Short: "Apply the changes to upstream catalog",
                Long: heredoc.Doc(`
                        The tool reads the current state of local catalog defined by the customer. It identifies
                        the changes based on the last recorded state. The diff is then applied to the upstream.
                `),
                Example: heredoc.Doc(`
                        $ rudder-cli tp apply --location &lt;/path/to/dir or file&gt; --dry-run
                `),
                PreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        deps, err = app.NewDeps()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("initialising dependencies: %w", err)
                        }</span>

                        <span class="cov0" title="0">p = project.New(location, deps.Providers().DataCatalog)
                        if err := p.Load(); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("loading project: %w", err)
                        }</span>

                        <span class="cov0" title="0">return err</span>
                },
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        log.Debug("tp apply", "dryRun", dryRun, "confirm", confirm)
                        log.Debug("identifying changes for the upstream catalog")

                        defer func() </span><span class="cov0" title="0">{
                                telemetry.TrackCommand("tp apply", err, []telemetry.KV{
                                        {K: "dryRun", V: dryRun},
                                        {K: "confirm", V: confirm},
                                }...)
                        }</span>()

                        <span class="cov0" title="0">graph, err := p.GetResourceGraph()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("getting resource graph: %w", err)
                        }</span>

                        <span class="cov0" title="0">s, err := syncer.New(deps.CompositeProvider())
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">err = s.Sync(
                                context.Background(),
                                graph,
                                syncer.SyncOptions{
                                        DryRun:  dryRun,
                                        Confirm: confirm,
                                })

                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("syncing the state: %w", err)
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().StringVarP(&amp;location, "location", "l", "", "Path to the directory containing the catalog files  or catalog file itself")
        cmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Only show the changes and not apply them")
        cmd.Flags().BoolVar(&amp;confirm, "confirm", true, "Confirm the changes before applying")
        return cmd</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package apply

import (
        "context"
        "fmt"

        "github.com/MakeNowJust/heredoc/v2"
        "github.com/rudderlabs/rudder-iac/cli/internal/app"
        "github.com/rudderlabs/rudder-iac/cli/internal/cmd/telemetry"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer"
        "github.com/rudderlabs/rudder-iac/cli/pkg/logger"
        "github.com/spf13/cobra"
)

var log = logger.New("trackingplan", logger.Attr{
        Key:   "cmd",
        Value: "destroy",
})

func NewCmdTPDestroy() *cobra.Command <span class="cov0" title="0">{
        var (
                dryRun  bool
                confirm bool
        )

        cmd := &amp;cobra.Command{
                Use:   "destroy",
                Short: "Delete all resources from both the upstream catalog and state",
                Long: heredoc.Doc(`
                        Delete all resources from both the upstream catalog and state
                `),
                Example: heredoc.Doc(`
                        $ rudder-cli tp destroy --dry-run
                `),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        var err error
                        log.Debug("tp destroy", "dryRun", dryRun, "confirm", confirm)

                        defer func() </span><span class="cov0" title="0">{
                                telemetry.TrackCommand("tp destroy", err, []telemetry.KV{
                                        {K: "dryRun", V: dryRun},
                                        {K: "confirm", V: confirm},
                                }...)
                        }</span>()

                        <span class="cov0" title="0">deps, err := app.NewDeps()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("initialising dependencies: %w", err)
                        }</span>

                        <span class="cov0" title="0">s, err := syncer.New(deps.CompositeProvider())
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">errors := s.Destroy(context.Background(), syncer.SyncOptions{
                                DryRun:  dryRun,
                                Confirm: confirm,
                        })
                        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("destroying resources: %w", errors[0])
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Only show the changes and not apply them")
        cmd.Flags().BoolVar(&amp;confirm, "confirm", true, "Confirm the changes before applying")
        return cmd</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package trackingplan

import (
        "github.com/MakeNowJust/heredoc/v2"
        "github.com/spf13/cobra"

        tpApplyCmd "github.com/rudderlabs/rudder-iac/cli/internal/cmd/trackingplan/apply"
        tpDestroyCmd "github.com/rudderlabs/rudder-iac/cli/internal/cmd/trackingplan/destroy"
        tpValidateCmd "github.com/rudderlabs/rudder-iac/cli/internal/cmd/trackingplan/validate"
)

func NewCmdTrackingPlan() *cobra.Command <span class="cov0" title="0">{

        cmd := &amp;cobra.Command{
                Use:   "tp &lt;command&gt;",
                Short: "Manage datacatalog resources",
                Long:  "Manage the lifecycle of datacatalog resources using user defined state",
                Example: heredoc.Doc(`
                        $ rudder-cli tp validate
                        $ rudder-cli tp apply
                `),
        }

        cmd.AddCommand(tpValidateCmd.NewCmdTPValidate())
        cmd.AddCommand(tpApplyCmd.NewCmdTPApply())
        cmd.AddCommand(tpDestroyCmd.NewCmdTPDestroy())

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package validate

import (
        "fmt"

        "github.com/MakeNowJust/heredoc/v2"
        "github.com/rudderlabs/rudder-iac/cli/internal/app"
        "github.com/rudderlabs/rudder-iac/cli/internal/cmd/telemetry"
        "github.com/rudderlabs/rudder-iac/cli/internal/project"
        "github.com/rudderlabs/rudder-iac/cli/pkg/logger"
        "github.com/spf13/cobra"
)

var (
        log = logger.New("trackingplan", logger.Attr{
                Key:   "cmd",
                Value: "validate",
        })
)

func NewCmdTPValidate() *cobra.Command <span class="cov0" title="0">{
        var (
                location string
                err      error
        )

        cmd := &amp;cobra.Command{
                Use:   "validate",
                Short: "Validate locally defined catalog",
                Long:  "Validate locally defined catalog",
                Example: heredoc.Doc(`
                        $ rudder-cli tp validate --location &lt;path-to-catalog-dir or file&gt;
                `),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                telemetry.TrackCommand("tp validate", err)
                        }</span>()

                        <span class="cov0" title="0">deps, err := app.NewDeps()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("initialising dependencies: %w", err)
                        }</span>

                        <span class="cov0" title="0">p := project.New(location, deps.CompositeProvider())

                        if err := p.Load(); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("loading project: %w", err)
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().StringVarP(&amp;location, "location", "l", "", "Path to the directory containing the catalog files or catalog file itself")
        return cmd</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/rudderlabs/rudder-iac/api/client"
        "github.com/rudderlabs/rudder-iac/cli/pkg/logger"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
        "github.com/tidwall/pretty"
        "github.com/tidwall/sjson"
)

var (
        log = logger.New("config")
        // Below variables are set during build time using ldflags
        // and locations are defined in the Makefile. Any changes
        // to the below variables should be reflected in the Makefile
        TelemetryWriteKey     = ""
        TelemetryDataplaneURL = ""
)

type Config = struct {
        Debug        bool   `mapstructure:"debug"`
        Experimental bool   `mapstructure:"experimental"`
        Verbose      bool   `mapstructure:"verbose"`
        APIURL       string `mapstructure:"apiURL"`
        Auth         struct {
                AccessToken string `mapstructure:"accessToken"`
        } `mapstructure:"auth"`
        Telemetry struct {
                Disabled     bool   `mapstructure:"disabled"`
                AnonymousID  string `mapstructure:"anonymousId"`
                WriteKey     string `mapstructure:"writeKey"`
                DataplaneURL string `mapstructure:"dataplaneURL"`
        } `mapstructure:"telemetry"`
}

func defaultConfigPath() string <span class="cov0" title="0">{
        homeDir, err := os.UserHomeDir()
        cobra.CheckErr(err)

        return fmt.Sprintf("%s/.rudder", homeDir)
}</span>

func DefaultConfigFile() string <span class="cov0" title="0">{
        return filepath.Join(defaultConfigPath(), "config.json")
}</span>

func InitConfig(cfgFile string) <span class="cov0" title="0">{
        log.Debug("initializing the configuration", "location", cfgFile)

        if cfgFile != "" </span>{<span class="cov0" title="0">
                // Use config file from the flag.
        }</span> else<span class="cov0" title="0"> {
                cfgFile = DefaultConfigFile()
        }</span>

        <span class="cov0" title="0">err := createConfigFileIfNotExists(cfgFile)
        cobra.CheckErr(err)

        viper.SetConfigFile(cfgFile)

        // set defaults
        viper.SetDefault("debug", false)
        viper.SetDefault("experimental", false)
        viper.SetDefault("verbose", false)
        viper.SetDefault("apiURL", client.BASE_URL_V2)
        viper.SetDefault("telemetry.disabled", false)
        viper.SetDefault("telemetry.writeKey", TelemetryWriteKey)
        viper.SetDefault("telemetry.dataplaneURL", TelemetryDataplaneURL)

        viper.BindEnv("auth.accessToken", "RUDDERSTACK_ACCESS_TOKEN")
        viper.BindEnv("apiURL", "RUDDERSTACK_API_URL")
        viper.BindEnv("experimental", "RUDDERSTACK_CLI_EXPERIMENTAL")
        viper.BindEnv("telemetry.writeKey", "RUDDERSTACK_CLI_TELEMETRY_WRITE_KEY")
        viper.BindEnv("telemetry.dataplaneURL", "RUDDERSTACK_CLI_TELEMETRY_DATAPLANE_URL")
        viper.BindEnv("telemetry.disabled", "RUDDERSTACK_CLI_TELEMETRY_DISABLED")

        // load configuration
        _ = viper.ReadInConfig()</span>
}

func createConfigFileIfNotExists(cfgFile string) error <span class="cov0" title="0">{
        configPath := filepath.Dir(cfgFile)

        if _, err := os.Stat(cfgFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                log.Info("Config file not found, creating default configuration", "location", cfgFile)

                if err := os.MkdirAll(configPath, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error creating config directory: %v", err)
                }</span>

                <span class="cov0" title="0">file, err := os.Create(cfgFile)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error creating config file: %v", err)
                }</span>
                <span class="cov0" title="0">defer file.Close()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func SetAccessToken(accessToken string) <span class="cov0" title="0">{
        updateConfig(func(data []byte) ([]byte, error) </span><span class="cov0" title="0">{
                return sjson.SetBytes(data, "auth.accessToken", accessToken)
        }</span>)
}

func SetTelemetryDisabled(disabled bool) <span class="cov0" title="0">{
        updateConfig(func(data []byte) ([]byte, error) </span><span class="cov0" title="0">{
                return sjson.SetBytes(data, "telemetry.disabled", disabled)
        }</span>)
}

func SetTelemetryAnonymousID(anonymousID string) <span class="cov0" title="0">{
        updateConfig(func(data []byte) ([]byte, error) </span><span class="cov0" title="0">{
                return sjson.SetBytes(data, "telemetry.anonymousID", anonymousID)
        }</span>)
}

func updateConfig(f func(data []byte) ([]byte, error)) <span class="cov0" title="0">{
        configFile := viper.ConfigFileUsed()
        data, err := os.ReadFile(configFile)
        cobra.CheckErr(err)

        newData, err := f(data)
        cobra.CheckErr(err)

        formattedData := pretty.Pretty(newData)

        err = os.WriteFile(configFile, formattedData, 0644)
        cobra.CheckErr(err)

        _ = viper.ReadInConfig()
}</span>

func GetConfig() Config <span class="cov0" title="0">{
        var config Config
        err := viper.Unmarshal(&amp;config)
        cobra.CheckErr(err)

        return config
}</span>

func GetConfigDir() string <span class="cov0" title="0">{
        return filepath.Dir(viper.ConfigFileUsed())
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package loader

import (
        "fmt"
        "io"
        "os"
        "path/filepath"

        "github.com/rudderlabs/rudder-iac/cli/internal/project/specs"
        "github.com/rudderlabs/rudder-iac/cli/pkg/logger"
)

var log = logger.New("loader")

// Loader is responsible for finding and loading project specification files.
type Loader struct {
}

// Load scans the configured location for YAML files (.yaml or .yml).
// It walks the directory tree recursively to discover them, and parses them into Spec objects.
// It returns a map of file paths to their corresponding Spec objects,
// or an error if any file operation or spec parsing fails.
func (l *Loader) Load(location string) (map[string]*specs.Spec, error) <span class="cov8" title="1">{
        var allSpecs map[string]*specs.Spec = make(map[string]*specs.Spec)

        log.Info("loading specs", "location", location)

        err := filepath.WalkDir(location, func(path string, d os.DirEntry, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("walking path %s: %w", path, err)
                }</span>

                // Skip directories
                <span class="cov8" title="1">if d.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Check file extension
                <span class="cov8" title="1">ext := filepath.Ext(path)
                if ext != ".yaml" &amp;&amp; ext != ".yml" </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Read file
                <span class="cov8" title="1">f, err := os.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("opening file: %w", err)
                }</span>
                <span class="cov8" title="1">defer f.Close()

                data, err := io.ReadAll(f)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("reading file: %w", err)
                }</span>

                // Parse spec
                <span class="cov8" title="1">spec, err := specs.New(data)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("parsing spec file %s: %w", path, err)
                }</span>

                <span class="cov8" title="1">allSpecs[path] = spec
                return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("loading specs: %w", err)
        }</span>

        <span class="cov8" title="1">return allSpecs, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package project

import (
        "fmt"
        "slices"

        "github.com/rudderlabs/rudder-iac/cli/internal/project/loader"
        "github.com/rudderlabs/rudder-iac/cli/internal/project/specs"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
)

// SpecLoader defines the interface for loading project specifications.
type Loader interface {
        // Load loads specifications from the specified location.
        Load(location string) (map[string]*specs.Spec, error)
}

type ProjectProvider interface {
        GetSupportedKinds() []string
        GetSupportedTypes() []string
        Validate() error
        LoadSpec(path string, s *specs.Spec) error
        GetResourceGraph() (*resources.Graph, error)
}

type Provider interface {
        ProjectProvider
        syncer.SyncProvider
}

type Project interface {
        Load() error
        GetResourceGraph() (*resources.Graph, error)
}

type project struct {
        Location string
        Provider Provider
        loader   Loader // New field
        // specs      []*specs.Spec // This seems to be handled by the provider internally via LoadSpec
}

// ProjectOption defines a functional option for configuring a Project.
type ProjectOption func(*project)

// WithSpecLoader allows providing a custom SpecLoader.
func WithLoader(l Loader) ProjectOption <span class="cov8" title="1">{
        return func(p *project) </span><span class="cov8" title="1">{
                if l != nil </span><span class="cov8" title="1">{
                        p.loader = l
                }</span>
        }
}

// New creates a new Project instance.
// By default, it uses a loader.Loader.
func New(location string, provider Provider, opts ...ProjectOption) Project <span class="cov8" title="1">{
        p := &amp;project{
                Location: location,
                Provider: provider,
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(p)
        }</span>

        <span class="cov8" title="1">if p.loader == nil </span><span class="cov8" title="1">{
                p.loader = &amp;loader.Loader{}
        }</span>

        <span class="cov8" title="1">return p</span>
}

// Load loads the project specifications using the configured SpecLoader
// and then validates them with the provider.
func (p *project) Load() error <span class="cov8" title="1">{
        loadedSpecs, err := p.loader.Load(p.Location) // Use the specLoader
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to load specs using specLoader: %w", err)
        }</span>

        // The rest of the logic from old loadSpecs
        <span class="cov8" title="1">for path, spec := range loadedSpecs </span><span class="cov8" title="1">{
                if !slices.Contains(p.Provider.GetSupportedKinds(), spec.Kind) </span><span class="cov8" title="1">{
                        return specs.ErrUnsupportedKind{
                                Kind: spec.Kind,
                        }
                }</span>
                <span class="cov8" title="1">if err := p.Provider.LoadSpec(path, spec); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("provider failed to load spec from path %s: %w", path, err)
                }</span>
        }

        <span class="cov8" title="1">return p.Provider.Validate()</span>
}

func (p *project) GetResourceGraph() (*resources.Graph, error) <span class="cov8" title="1">{
        return p.Provider.GetResourceGraph()
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package specs

import (
        "fmt"

        "gopkg.in/yaml.v3"
)

type Spec struct {
        Version  string                 `yaml:"version"`
        Kind     string                 `yaml:"kind"`
        Metadata map[string]interface{} `yaml:"metadata"`
        Spec     map[string]interface{} `yaml:"spec"`
}

// New creates and validates a Spec from YAML data
func New(data []byte) (*Spec, error) <span class="cov8" title="1">{
        var spec Spec
        if err := yaml.Unmarshal(data, &amp;spec); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unmarshaling yaml: %w", err)
        }</span>

        <span class="cov8" title="1">if spec.Version == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("missing required field 'version'")
        }</span>
        <span class="cov8" title="1">if spec.Kind == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("missing required field 'kind'")
        }</span>
        <span class="cov8" title="1">if spec.Metadata == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("missing required field 'metadata'")
        }</span>
        <span class="cov8" title="1">if spec.Spec == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("missing required field 'spec'")
        }</span>

        <span class="cov8" title="1">return &amp;spec, nil</span>
}

type ErrUnsupportedKind struct {
        Kind string
}

func (e ErrUnsupportedKind) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("unsupported kind: %s", e.Kind)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package providers

import (
        "context"
        "fmt"

        "github.com/rudderlabs/rudder-iac/cli/internal/project"
        "github.com/rudderlabs/rudder-iac/cli/internal/project/specs"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/state"
        "golang.org/x/exp/maps"
)

type CompositeProvider struct {
        Providers       []project.Provider
        registeredKinds map[string]project.Provider
        registeredTypes map[string]project.Provider
}

func NewCompositeProvider(providers ...project.Provider) (*CompositeProvider, error) <span class="cov8" title="1">{
        if len(providers) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("at least one provider must be specified")
        }</span>

        <span class="cov8" title="1">registeredKinds := make(map[string]project.Provider)
        registeredTypes := make(map[string]project.Provider)

        for _, provider := range providers </span><span class="cov8" title="1">{
                for _, kind := range provider.GetSupportedKinds() </span><span class="cov8" title="1">{
                        if _, ok := registeredKinds[kind]; ok </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("duplicate kind '%s' supported by multiple providers", kind)
                        }</span>
                        <span class="cov8" title="1">registeredKinds[kind] = provider</span>
                }
                <span class="cov8" title="1">for _, t := range provider.GetSupportedTypes() </span><span class="cov8" title="1">{
                        if _, ok := registeredTypes[t]; ok </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("duplicate type '%s' supported by multiple providers", t)
                        }</span>
                        <span class="cov8" title="1">registeredTypes[t] = provider</span>
                }
        }

        <span class="cov8" title="1">return &amp;CompositeProvider{
                Providers:       providers,
                registeredKinds: registeredKinds,
                registeredTypes: registeredTypes,
        }, nil</span>
}

func (p *CompositeProvider) GetSupportedKinds() []string <span class="cov8" title="1">{
        return maps.Keys(p.registeredKinds)
}</span>

func (p *CompositeProvider) GetSupportedTypes() []string <span class="cov8" title="1">{
        return maps.Keys(p.registeredTypes)
}</span>

func (p *CompositeProvider) Validate() error <span class="cov8" title="1">{
        for _, provider := range p.Providers </span><span class="cov8" title="1">{
                if err := provider.Validate(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (p *CompositeProvider) LoadSpec(path string, s *specs.Spec) error <span class="cov8" title="1">{
        provider := p.providerForKind(s.Kind)
        if provider == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no provider found for kind %s", s.Kind)
        }</span>
        <span class="cov8" title="1">return provider.LoadSpec(path, s)</span>
}

func (p *CompositeProvider) GetResourceGraph() (*resources.Graph, error) <span class="cov8" title="1">{
        graph := resources.NewGraph()
        for _, provider := range p.Providers </span><span class="cov8" title="1">{
                g, err := provider.GetResourceGraph()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">graph.Merge(g)</span>
        }
        <span class="cov8" title="1">return graph, nil</span>
}

func (p *CompositeProvider) LoadState(ctx context.Context) (*state.State, error) <span class="cov8" title="1">{
        var state *state.State = nil
        for _, provider := range p.Providers </span><span class="cov8" title="1">{
                s, err := provider.LoadState(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if state == nil </span><span class="cov8" title="1">{
                        state = s
                }</span> else<span class="cov8" title="1"> {
                        state, err = state.Merge(s)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error merging provider states")
                        }</span>
                }
        }

        <span class="cov8" title="1">return state, nil</span>
}

func (p *CompositeProvider) PutResourceState(ctx context.Context, URN string, state *state.ResourceState) error <span class="cov8" title="1">{
        provider := p.providerForType(state.Type)
        if provider == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no provider found for resource type %s", state.Type)
        }</span>
        <span class="cov8" title="1">return provider.PutResourceState(ctx, URN, state)</span>
}

func (p *CompositeProvider) DeleteResourceState(ctx context.Context, state *state.ResourceState) error <span class="cov8" title="1">{
        provider := p.providerForType(state.Type)
        if provider == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no provider found for resource type %s", state.Type)
        }</span>
        <span class="cov8" title="1">return provider.DeleteResourceState(ctx, state)</span>
}

func (p *CompositeProvider) Create(ctx context.Context, ID string, resourceType string, data resources.ResourceData) (*resources.ResourceData, error) <span class="cov8" title="1">{
        provider := p.providerForType(resourceType)
        if provider == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no provider found for resource type %s", resourceType)
        }</span>
        <span class="cov8" title="1">return provider.Create(ctx, ID, resourceType, data)</span>
}

func (p *CompositeProvider) Update(ctx context.Context, ID string, resourceType string, data resources.ResourceData, state resources.ResourceData) (*resources.ResourceData, error) <span class="cov8" title="1">{
        provider := p.providerForType(resourceType)
        if provider == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no provider found for resource type %s", resourceType)
        }</span>
        <span class="cov8" title="1">return provider.Update(ctx, ID, resourceType, data, state)</span>
}

func (p *CompositeProvider) Delete(ctx context.Context, ID string, resourceType string, state resources.ResourceData) error <span class="cov8" title="1">{
        provider := p.providerForType(resourceType)
        if provider == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no provider found for resource type %s", resourceType)
        }</span>
        <span class="cov8" title="1">return provider.Delete(ctx, ID, resourceType, state)</span>
}

// Helper methods
func (p *CompositeProvider) providerForKind(kind string) project.Provider <span class="cov8" title="1">{
        return p.registeredKinds[kind]
}</span>

func (p *CompositeProvider) providerForType(resourceType string) project.Provider <span class="cov8" title="1">{
        return p.registeredTypes[resourceType]
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package datacatalog

import (
        "fmt"
        "strings"

        "github.com/rudderlabs/rudder-iac/api/client/catalog"
        "github.com/rudderlabs/rudder-iac/cli/internal/project/specs"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
        "github.com/rudderlabs/rudder-iac/cli/pkg/localcatalog"
        "github.com/rudderlabs/rudder-iac/cli/pkg/logger"
        "github.com/rudderlabs/rudder-iac/cli/pkg/provider"
        pstate "github.com/rudderlabs/rudder-iac/cli/pkg/provider/state"
        "github.com/rudderlabs/rudder-iac/cli/pkg/validate"
)

var log = logger.New("datacatalogprovider")

type Provider struct {
        syncer.SyncProvider
        client catalog.DataCatalog
        dc     *localcatalog.DataCatalog
}

func New(client catalog.DataCatalog) *Provider <span class="cov0" title="0">{
        return &amp;Provider{
                SyncProvider: provider.NewCatalogProvider(client),
                client:       client,
                dc:           localcatalog.New(),
        }
}</span>

func (p *Provider) LoadSpec(path string, s *specs.Spec) error <span class="cov0" title="0">{
        return p.dc.LoadSpec(path, s)
}</span>

func (p *Provider) GetSupportedKinds() []string <span class="cov0" title="0">{
        return []string{"properties", "events", "tp"}
}</span>

func (p *Provider) GetSupportedTypes() []string <span class="cov0" title="0">{
        return []string{
                "property",
                "event",
                "trackingplan",
        }
}</span>

func (p *Provider) GetLocalCatalog() *localcatalog.DataCatalog <span class="cov0" title="0">{
        return p.dc
}</span>

func (p *Provider) Validate() error <span class="cov0" title="0">{
        err := validate.ValidateCatalog(p.dc)
        if err == nil </span><span class="cov0" title="0">{
                log.Info("successfully validated the catalog")
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("catalog is invalid: %s", err.Error())</span>
}

func (p *Provider) GetResourceGraph() (*resources.Graph, error) <span class="cov0" title="0">{
        if err := inflateRefs(p.dc); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("inflating refs: %w", err)
        }</span>

        <span class="cov0" title="0">return createResourceGraph(p.dc)</span>
}

func createResourceGraph(catalog *localcatalog.DataCatalog) (*resources.Graph, error) <span class="cov0" title="0">{
        graph := resources.NewGraph()

        // First, pre-calculate all URNs to use for references
        propIDToURN := make(map[string]string)
        for _, props := range catalog.Properties </span><span class="cov0" title="0">{
                for _, prop := range props </span><span class="cov0" title="0">{
                        propIDToURN[prop.LocalID] = resources.URN(prop.LocalID, provider.PropertyResourceType)
                }</span>
        }

        <span class="cov0" title="0">eventIDToURN := make(map[string]string)
        for _, events := range catalog.Events </span><span class="cov0" title="0">{
                for _, event := range events </span><span class="cov0" title="0">{
                        eventIDToURN[event.LocalID] = resources.URN(event.LocalID, provider.EventResourceType)
                }</span>
        }

        <span class="cov0" title="0">customTypeIDToURN := make(map[string]string)
        for _, customTypes := range catalog.CustomTypes </span><span class="cov0" title="0">{
                for _, customType := range customTypes </span><span class="cov0" title="0">{
                        customTypeIDToURN[customType.LocalID] = resources.URN(customType.LocalID, provider.CustomTypeResourceType)
                }</span>
        }

        // Helper function to get URN from reference
        <span class="cov0" title="0">getURNFromRef := func(ref string) string </span><span class="cov0" title="0">{
                // Format: #/entities/group/id
                parts := strings.Split(ref, "/")
                if len(parts) &lt; 4 </span><span class="cov0" title="0">{
                        return ""
                }</span>

                <span class="cov0" title="0">var (
                        entityType = parts[1]
                        id         = parts[3]
                )

                switch entityType </span>{
                case "properties":<span class="cov0" title="0">
                        return propIDToURN[id]</span>
                case "custom-types":<span class="cov0" title="0">
                        return customTypeIDToURN[id]</span>
                default:<span class="cov0" title="0">
                        return ""</span>
                }
        }

        // Add properties to the graph
        <span class="cov0" title="0">for group, props := range catalog.Properties </span><span class="cov0" title="0">{
                for _, prop := range props </span><span class="cov0" title="0">{
                        log.Debug("adding property to graph", "id", prop.LocalID, "group", group)

                        args := &amp;pstate.PropertyArgs{}
                        if err := args.FromCatalogPropertyType(prop, getURNFromRef); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("creating property args from catalog property: %s, err:%w", prop.LocalID, err)
                        }</span>

                        <span class="cov0" title="0">resource := resources.NewResource(prop.LocalID, provider.PropertyResourceType, args.ToResourceData(), make([]string, 0))
                        graph.AddResource(resource)

                        propIDToURN[prop.LocalID] = resource.URN()</span>
                }
        }

        // Add events to the graph
        <span class="cov0" title="0">for group, events := range catalog.Events </span><span class="cov0" title="0">{
                for _, event := range events </span><span class="cov0" title="0">{
                        log.Debug("adding event to graph", "event", event.LocalID, "group", group)

                        args := pstate.EventArgs{
                                Name:        event.Name,
                                Description: event.Description,
                                EventType:   event.Type,
                                CategoryID:  nil,
                        }
                        resource := resources.NewResource(event.LocalID, provider.EventResourceType, args.ToResourceData(), make([]string, 0))
                        graph.AddResource(resource)

                        eventIDToURN[event.LocalID] = resource.URN()
                }</span>
        }

        // Add custom types to the graph with dependencies on properties or other custom types
        <span class="cov0" title="0">for group, customTypes := range catalog.CustomTypes </span><span class="cov0" title="0">{
                for _, customType := range customTypes </span><span class="cov0" title="0">{
                        log.Debug("adding custom type to graph", "id", customType.LocalID, "group", group)

                        // Add CustomTypeArgs
                        args := pstate.CustomTypeArgs{}
                        args.FromCatalogCustomType(&amp;customType, getURNFromRef)
                        resource := resources.NewResource(customType.LocalID, provider.CustomTypeResourceType, args.ToResourceData(), make([]string, 0))
                        graph.AddResource(resource)
                }</span>
        }

        // Add tracking plans to the graph
        <span class="cov0" title="0">for group, tp := range catalog.TrackingPlans </span><span class="cov0" title="0">{
                log.Debug("adding tracking plan to graph", "tp", tp.LocalID, "group", group)

                args := pstate.TrackingPlanArgs{}
                if err := args.FromCatalogTrackingPlan(tp, getURNFromRef); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("creating tracking plan args: %w", err)
                }</span>

                <span class="cov0" title="0">resource := resources.NewResource(tp.LocalID, provider.TrackingPlanResourceType, args.ToResourceData(), make([]string, 0))
                graph.AddResource(resource)
                graph.AddDependencies(resource.URN(), getDependencies(tp, propIDToURN, eventIDToURN))</span>
        }

        <span class="cov0" title="0">return graph, nil</span>
}

// getDependencies simply fetch the dependencies on the trackingplan in form of the URN's
// of the properties and events that are used in the tracking plan
func getDependencies(tp *localcatalog.TrackingPlan, propIDToURN, eventIDToURN map[string]string) []string <span class="cov0" title="0">{
        dependencies := make([]string, 0)

        for _, event := range tp.EventProps </span><span class="cov0" title="0">{
                if urn, ok := eventIDToURN[event.LocalID]; ok </span><span class="cov0" title="0">{
                        dependencies = append(dependencies, urn)
                }</span>

                <span class="cov0" title="0">for _, prop := range event.Properties </span><span class="cov0" title="0">{
                        if urn, ok := propIDToURN[prop.LocalID]; ok </span><span class="cov0" title="0">{
                                dependencies = append(dependencies, urn)
                        }</span>
                }
        }

        <span class="cov0" title="0">return dependencies</span>
}

func inflateRefs(catalog *localcatalog.DataCatalog) error <span class="cov0" title="0">{
        log.Debug("inflating all the references in the catalog")

        for _, tp := range catalog.TrackingPlans </span><span class="cov0" title="0">{
                if err := tp.ExpandRefs(catalog); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("expanding refs on tp: %s err: %w", tp.LocalID, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package retl

import "fmt"

type SQLModelSpec struct {
        ID          string  `json:"id"`
        DisplayName string  `json:"display_name"`
        Description string  `json:"description"`
        File        *string `json:"file"`
        SQL         *string `json:"sql"`
        AccountID   string  `json:"account_id"`
        PrimaryKey  string  `json:"primary_key"`
}

func ValidateSQLModelSpec(spec *SQLModelSpec) error <span class="cov0" title="0">{
        if spec.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("id is required")
        }</span>
        <span class="cov0" title="0">if spec.DisplayName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("display_name is required")
        }</span>
        <span class="cov0" title="0">if spec.Description == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("description is required")
        }</span>
        <span class="cov0" title="0">if spec.File == nil &amp;&amp; spec.SQL == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("either file or sql is required")
        }</span>
        <span class="cov0" title="0">if spec.AccountID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("account_id is required")
        }</span>
        <span class="cov0" title="0">if spec.PrimaryKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("primary_key is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package retl

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/rudderlabs/rudder-iac/cli/internal/project/specs"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/state"
)

type Provider struct {
        sqlModelSpecs []*SQLModelSpec
}

func New() *Provider <span class="cov0" title="0">{
        return &amp;Provider{
                sqlModelSpecs: []*SQLModelSpec{},
        }
}</span>

func (p *Provider) GetSupportedKinds() []string <span class="cov0" title="0">{
        return []string{"retl-sql-model"}
}</span>

func (p *Provider) GetSupportedTypes() []string <span class="cov0" title="0">{
        return []string{
                "sql-model",
        }
}</span>

func (p *Provider) LoadSpec(path string, s *specs.Spec) error <span class="cov0" title="0">{
        switch s.Kind </span>{
        case "retl-sql-model":<span class="cov0" title="0">
                spec := &amp;SQLModelSpec{}

                jsonByt, err := json.Marshal(s.Spec)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("marshalling the spec: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal(jsonByt, &amp;spec); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("extracting the property spec: %w", err)
                }</span>

                <span class="cov0" title="0">p.sqlModelSpecs = append(p.sqlModelSpecs, spec)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (p *Provider) Validate() error <span class="cov0" title="0">{
        for _, spec := range p.sqlModelSpecs </span><span class="cov0" title="0">{
                if err := ValidateSQLModelSpec(spec); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("validating sql model spec: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (p *Provider) GetResourceGraph() (*resources.Graph, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (p *Provider) LoadState(ctx context.Context) (*state.State, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (p *Provider) PutResourceState(ctx context.Context, URN string, state *state.ResourceState) error <span class="cov0" title="0">{
        return nil
}</span>

func (p *Provider) DeleteResourceState(ctx context.Context, state *state.ResourceState) error <span class="cov0" title="0">{
        return nil
}</span>

func (p *Provider) Create(ctx context.Context, ID string, resourceType string, data resources.ResourceData) (*resources.ResourceData, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (p *Provider) Update(ctx context.Context, ID string, resourceType string, data resources.ResourceData, state resources.ResourceData) (*resources.ResourceData, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (p *Provider) Delete(ctx context.Context, ID string, resourceType string, state resources.ResourceData) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package config

import (
        "fmt"
        "os"
)

// Config holds the configuration for the schema operations
type Config struct {
        APIToken string
        APIURL   string
}

// LoadConfig loads configuration from environment variables
func LoadConfig() (*Config, error) <span class="cov8" title="1">{
        apiToken := os.Getenv("RUDDERSTACK_ACCESS_TOKEN")
        if apiToken == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("access token is required. Please run 'rudder-cli auth login' or set RUDDERSTACK_ACCESS_TOKEN environment variable")
        }</span>

        <span class="cov8" title="1">apiURL := os.Getenv("RUDDERSTACK_API_URL")
        if apiURL == "" </span><span class="cov8" title="1">{
                // Use default URL if not provided
                apiURL = "https://api.rudderstack.com"
        }</span>

        <span class="cov8" title="1">return &amp;Config{
                APIToken: apiToken,
                APIURL:   apiURL,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package converter

import (
        "crypto/md5"
        "fmt"
        "math/rand"
        "sort"
        "strings"

        "github.com/rudderlabs/rudder-iac/cli/internal/schema/models"
)

// SchemaAnalyzer analyzes schemas to extract events, properties, and custom types
type SchemaAnalyzer struct {
        Events      map[string]*EventInfo
        Properties  map[string]*PropertyInfo
        CustomTypes map[string]*CustomTypeInfo

        // Uniqueness tracking
        UsedCustomTypeNames map[string]bool
        UsedPropertyIDs     map[string]bool
        UsedEventIDs        map[string]bool
}

// EventInfo holds information about an extracted event
type EventInfo struct {
        ID          string
        Name        string
        EventType   string
        Description string
        Original    models.Schema
}

// PropertyInfo holds information about an extracted property
type PropertyInfo struct {
        ID          string
        Name        string
        Type        string
        Description string
        Path        string
        JsonType    string
}

// CustomTypeInfo holds information about a custom type
type CustomTypeInfo struct {
        ID            string
        Name          string
        Type          string
        Description   string
        Structure     map[string]string
        ArrayItemType string
        Hash          string
}

// NewSchemaAnalyzer creates a new schema analyzer
func NewSchemaAnalyzer() *SchemaAnalyzer <span class="cov8" title="1">{
        return &amp;SchemaAnalyzer{
                Events:              make(map[string]*EventInfo),
                Properties:          make(map[string]*PropertyInfo),
                CustomTypes:         make(map[string]*CustomTypeInfo),
                UsedCustomTypeNames: make(map[string]bool),
                UsedPropertyIDs:     make(map[string]bool),
                UsedEventIDs:        make(map[string]bool),
        }
}</span>

// AnalyzeSchemas processes all schemas to extract events, properties, and custom types
func (sa *SchemaAnalyzer) AnalyzeSchemas(schemas []models.Schema) error <span class="cov8" title="1">{
        // First pass: Extract unique events
        for _, schema := range schemas </span><span class="cov8" title="1">{
                sa.extractEvent(schema)
        }</span>

        // Second pass: Analyze properties and identify custom types
        <span class="cov8" title="1">for _, schema := range schemas </span><span class="cov8" title="1">{
                err := sa.analyzeProperties(schema.Schema, "")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to analyze properties for schema %s: %w", schema.UID, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// extractEvent extracts event information from a schema
func (sa *SchemaAnalyzer) extractEvent(schema models.Schema) <span class="cov8" title="1">{
        eventIdentifier := schema.EventIdentifier

        // Handle empty or invalid event identifiers
        if eventIdentifier == "" </span><span class="cov0" title="0">{
                eventIdentifier = "unknown_event"
        }</span>

        // Sanitize the event identifier to ensure it's valid
        <span class="cov8" title="1">eventID := sanitizeEventID(eventIdentifier)

        // If sanitization results in empty or very short ID, use fallback
        if len(eventID) &lt; 3 </span><span class="cov0" title="0">{
                eventID = fmt.Sprintf("event_%s", generateRandomID())
        }</span>

        // Check for uniqueness
        <span class="cov8" title="1">if _, exists := sa.Events[eventID]; exists </span><span class="cov8" title="1">{
                return // Event already processed
        }</span>

        <span class="cov8" title="1">eventName := generateEventName(eventIdentifier)

        event := &amp;EventInfo{
                ID:          eventID,
                Name:        eventName,
                EventType:   "track", // Default type
                Description: fmt.Sprintf("Extracted from eventIdentifier: %s", eventIdentifier),
                Original:    schema,
        }

        sa.Events[eventID] = event
        sa.UsedEventIDs[eventID] = true</span>
}

// analyzeProperties recursively analyzes schema properties
func (sa *SchemaAnalyzer) analyzeProperties(obj interface{}, path string) error <span class="cov8" title="1">{
        switch v := obj.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                return sa.analyzeObject(v, path)</span>
        case []interface{}:<span class="cov0" title="0">
                return sa.analyzeArray(v, path)</span>
        default:<span class="cov0" title="0">
                // Primitive type - create property
                return sa.createProperty(path, v)</span>
        }
}

// analyzeObject analyzes an object and potentially creates custom types
func (sa *SchemaAnalyzer) analyzeObject(obj map[string]interface{}, path string) error <span class="cov8" title="1">{
        // Create properties for each field
        for key, value := range obj </span><span class="cov8" title="1">{
                fieldPath := buildPath(path, key)

                switch v := value.(type) </span>{
                case map[string]interface{}:<span class="cov8" title="1">
                        // Nested object - create custom type
                        customType, err := sa.createCustomTypeForObject(v, fieldPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Create property referencing the custom type
                        <span class="cov8" title="1">err = sa.createPropertyWithCustomType(fieldPath, customType)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Recursively analyze the nested object
                        <span class="cov8" title="1">err = sa.analyzeObject(v, fieldPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                case []interface{}:<span class="cov8" title="1">
                        // Array - create custom array type
                        customType, err := sa.createCustomTypeForArray(v, fieldPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Create property referencing the custom type
                        <span class="cov8" title="1">err = sa.createPropertyWithCustomType(fieldPath, customType)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Recursively analyze array items
                        <span class="cov8" title="1">err = sa.analyzeArray(v, fieldPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                default:<span class="cov8" title="1">
                        // Primitive type
                        err := sa.createProperty(fieldPath, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// analyzeArray analyzes an array and its items
func (sa *SchemaAnalyzer) analyzeArray(arr []interface{}, path string) error <span class="cov8" title="1">{
        if len(arr) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Analyze first item to determine array type
        <span class="cov8" title="1">firstItem := arr[0]

        switch v := firstItem.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                // Array of objects - analyze the object structure
                return sa.analyzeObject(v, path+"_item")</span>
        case []interface{}:<span class="cov0" title="0">
                // Nested array - analyze recursively
                return sa.analyzeArray(v, path+"_item")</span>
        default:<span class="cov8" title="1">
                // Array of primitives - no further analysis needed
                return nil</span>
        }
}

// createCustomTypeForObject creates a custom type for an object
func (sa *SchemaAnalyzer) createCustomTypeForObject(obj map[string]interface{}, path string) (*CustomTypeInfo, error) <span class="cov8" title="1">{
        structure := make(map[string]string)

        // Analyze object structure
        for key, value := range obj </span><span class="cov8" title="1">{
                jsonType := getJSONType(value)
                structure[key] = jsonType
        }</span>

        // Generate hash for uniqueness
        <span class="cov8" title="1">hash := generateStructureHash(structure)

        // Check if custom type already exists
        for _, customType := range sa.CustomTypes </span><span class="cov8" title="1">{
                if customType.Hash == hash &amp;&amp; customType.Type == "object" </span><span class="cov0" title="0">{
                        return customType, nil
                }</span>
        }

        // Create new custom type with unique name
        <span class="cov8" title="1">customTypeID := generateCustomTypeID(path, "object", hash)
        customTypeName := sa.generateUniqueCustomTypeName(path, "object")

        customType := &amp;CustomTypeInfo{
                ID:          customTypeID,
                Name:        customTypeName,
                Type:        "object",
                Description: fmt.Sprintf("Custom object type for %s", path),
                Structure:   structure,
                Hash:        hash,
        }

        sa.CustomTypes[customTypeID] = customType
        return customType, nil</span>
}

// createCustomTypeForArray creates a custom type for an array
func (sa *SchemaAnalyzer) createCustomTypeForArray(arr []interface{}, path string) (*CustomTypeInfo, error) <span class="cov8" title="1">{
        if len(arr) == 0 </span><span class="cov0" title="0">{
                // Empty array - default to string array
                itemType := "string"
                hash := generateArrayHash(itemType)

                customTypeID := generateCustomTypeID(path, "array", hash)
                customTypeName := sa.generateUniqueCustomTypeName(path, "array")

                customType := &amp;CustomTypeInfo{
                        ID:            customTypeID,
                        Name:          customTypeName,
                        Type:          "array",
                        Description:   fmt.Sprintf("Custom array type for %s", path),
                        ArrayItemType: itemType,
                        Hash:          hash,
                }

                sa.CustomTypes[customTypeID] = customType
                return customType, nil
        }</span>

        // Determine array item type from first element
        <span class="cov8" title="1">firstItem := arr[0]
        itemType := getJSONType(firstItem)

        // For object arrays, we need to create a custom type for the object
        // and then reference it properly
        if itemType == "object" </span><span class="cov8" title="1">{
                if objMap, ok := firstItem.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        // Create custom type for the object
                        objectCustomType, err := sa.createCustomTypeForObject(objMap, path+"_item")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        // Set itemType to reference the custom object type
                        <span class="cov8" title="1">itemType = fmt.Sprintf("#/custom-types/extracted_custom_types/%s", objectCustomType.ID)</span>
                } else<span class="cov0" title="0"> {
                        // Fallback to generic object type
                        itemType = "object"
                }</span>
        } else<span class="cov8" title="1"> {
                // For primitive types, use the YAML type mapping
                itemType = mapJSONTypeToYAML(itemType)
        }</span>

        <span class="cov8" title="1">hash := generateArrayHash(itemType)

        // Check if custom type already exists
        for _, customType := range sa.CustomTypes </span><span class="cov8" title="1">{
                if customType.Hash == hash &amp;&amp; customType.Type == "array" </span><span class="cov0" title="0">{
                        return customType, nil
                }</span>
        }

        // Create new custom type
        <span class="cov8" title="1">customTypeID := generateCustomTypeID(path, "array", hash)
        customTypeName := sa.generateUniqueCustomTypeName(path, "array")

        customType := &amp;CustomTypeInfo{
                ID:            customTypeID,
                Name:          customTypeName,
                Type:          "array",
                Description:   fmt.Sprintf("Custom array type for %s", path),
                ArrayItemType: itemType,
                Hash:          hash,
        }

        sa.CustomTypes[customTypeID] = customType
        return customType, nil</span>
}

// createProperty creates a property for a primitive type
func (sa *SchemaAnalyzer) createProperty(path string, value interface{}) error <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return nil // Skip root level
        }</span>

        <span class="cov8" title="1">jsonType := getJSONType(value)
        yamlType := mapJSONTypeToYAML(jsonType)

        // Extract property name from path
        propertyName := extractPropertyName(path)

        // Skip if property name is empty (e.g., from malformed paths like "context.traits.")
        if propertyName == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create property key based on name + type for deduplication
        <span class="cov8" title="1">propertyKey := fmt.Sprintf("%s_%s", sanitizeID(propertyName), sanitizeID(yamlType))

        // Skip if property with same name+type already exists
        if _, exists := sa.Properties[propertyKey]; exists </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Generate unique property ID based on name and type combination
        <span class="cov8" title="1">propertyID := sa.generateUniquePropertyID(propertyName, yamlType)

        property := &amp;PropertyInfo{
                ID:          propertyID,
                Name:        propertyName,
                Type:        yamlType,
                Description: fmt.Sprintf("Property extracted from path: %s", path),
                Path:        path,
                JsonType:    jsonType,
        }

        sa.Properties[propertyKey] = property
        return nil</span>
}

// createPropertyWithCustomType creates a property that references a custom type
func (sa *SchemaAnalyzer) createPropertyWithCustomType(path string, customType *CustomTypeInfo) error <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">typeRef := fmt.Sprintf("#/custom-types/extracted_custom_types/%s", customType.ID)

        // Extract property name from path
        propertyName := extractPropertyName(path)

        // Skip if property name is empty (e.g., from malformed paths like "context.traits.")
        if propertyName == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create property key based on name + type for deduplication (same as primitive properties)
        <span class="cov8" title="1">propertyKey := fmt.Sprintf("%s_%s", sanitizeID(propertyName), sanitizeID(typeRef))

        // Skip if property with same name+type already exists
        if _, exists := sa.Properties[propertyKey]; exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Generate unique property ID based on name and type combination
        <span class="cov8" title="1">propertyID := sa.generateUniquePropertyID(propertyName, typeRef)

        property := &amp;PropertyInfo{
                ID:          propertyID,
                Name:        propertyName,
                Type:        typeRef,
                Description: fmt.Sprintf("Property with custom type from path: %s", path),
                Path:        path,
                JsonType:    customType.Type,
        }

        sa.Properties[propertyKey] = property
        return nil</span>
}

// Helper functions

func sanitizeID(input string) string <span class="cov8" title="1">{
        // Replace non-alphanumeric characters with underscores
        result := strings.ReplaceAll(input, ".", "_")
        result = strings.ReplaceAll(result, "-", "_")
        result = strings.ReplaceAll(result, " ", "_")
        result = strings.ToLower(result)
        return result
}</span>

func generateEventName(eventIdentifier string) string <span class="cov8" title="1">{
        // Convert snake_case to Title Case
        parts := strings.Split(eventIdentifier, "_")
        for i, part := range parts </span><span class="cov8" title="1">{
                if len(part) &gt; 0 </span><span class="cov8" title="1">{
                        parts[i] = strings.ToUpper(part[:1]) + part[1:]
                }</span>
        }
        <span class="cov8" title="1">return strings.Join(parts, " ")</span>
}

func buildPath(basePath, key string) string <span class="cov8" title="1">{
        if basePath == "" </span><span class="cov8" title="1">{
                return key
        }</span>
        <span class="cov8" title="1">return basePath + "." + key</span>
}

func extractPropertyName(path string) string <span class="cov8" title="1">{
        parts := strings.Split(path, ".")
        return parts[len(parts)-1]
}</span>

func getJSONType(value interface{}) string <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                return "null"
        }</span>

        <span class="cov8" title="1">switch value.(type) </span>{
        case string:<span class="cov8" title="1">
                return "string"</span>
        case float64:<span class="cov0" title="0">
                return "number"</span>
        case int, int64:<span class="cov0" title="0">
                return "integer"</span>
        case bool:<span class="cov0" title="0">
                return "boolean"</span>
        case map[string]interface{}:<span class="cov8" title="1">
                return "object"</span>
        case []interface{}:<span class="cov8" title="1">
                return "array"</span>
        default:<span class="cov0" title="0">
                // For type strings like "string", "float64", etc.
                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                        switch str </span>{
                        case "float64":<span class="cov0" title="0">
                                return "number"</span>
                        case "bool":<span class="cov0" title="0">
                                return "boolean"</span>
                        default:<span class="cov0" title="0">
                                return "string"</span>
                        }
                }
                <span class="cov0" title="0">return "string"</span>
        }
}

func mapJSONTypeToYAML(jsonType string) string <span class="cov8" title="1">{
        switch jsonType </span>{
        case "number":<span class="cov0" title="0">
                return "number"</span>
        case "integer":<span class="cov0" title="0">
                return "integer"</span>
        case "boolean":<span class="cov0" title="0">
                return "boolean"</span>
        case "object":<span class="cov0" title="0">
                return "object"</span>
        case "array":<span class="cov0" title="0">
                return "array"</span>
        case "null":<span class="cov0" title="0">
                return "null"</span>
        default:<span class="cov8" title="1">
                return "string"</span>
        }
}

func generatePropertyKey(path, propType string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s_%s", sanitizeID(path), sanitizeID(propType))
}</span>

func generateCustomTypeID(path, baseType, hash string) string <span class="cov8" title="1">{
        cleanPath := sanitizeID(path)
        return fmt.Sprintf("%s_%s_%s", cleanPath, baseType, hash[:8])
}</span>

func generateCustomTypeName(path, baseType string) string <span class="cov8" title="1">{
        // Clean the path to only contain letters
        cleanPath := strings.ReplaceAll(path, ".", "")
        cleanPath = strings.ReplaceAll(cleanPath, "_", "")
        cleanPath = strings.ReplaceAll(cleanPath, "-", "")
        cleanPath = strings.ReplaceAll(cleanPath, " ", "")

        // Remove any non-letter characters
        var letterOnly strings.Builder
        for _, char := range cleanPath </span><span class="cov8" title="1">{
                if (char &gt;= 'a' &amp;&amp; char &lt;= 'z') || (char &gt;= 'A' &amp;&amp; char &lt;= 'Z') </span><span class="cov8" title="1">{
                        letterOnly.WriteRune(char)
                }</span>
        }

        <span class="cov8" title="1">cleanPath = letterOnly.String()

        // Ensure we have at least some letters to work with
        if cleanPath == "" </span><span class="cov8" title="1">{
                cleanPath = "Generated"
        }</span>

        // Capitalize first letter
        <span class="cov8" title="1">if len(cleanPath) &gt; 0 </span><span class="cov8" title="1">{
                cleanPath = strings.ToUpper(cleanPath[:1]) + strings.ToLower(cleanPath[1:])
        }</span>

        // Add type suffix
        <span class="cov8" title="1">var typeName string
        if baseType == "array" </span><span class="cov8" title="1">{
                typeName = cleanPath + "Array"
        }</span> else<span class="cov8" title="1"> {
                typeName = cleanPath + "Type"
        }</span>

        // Ensure the name is between 3 and 65 characters
        <span class="cov8" title="1">if len(typeName) &lt; 3 </span><span class="cov0" title="0">{
                // Pad with "Type" if too short
                typeName = typeName + "Type"
                if len(typeName) &lt; 3 </span><span class="cov0" title="0">{
                        typeName = "GeneratedType"
                }</span>
        }

        <span class="cov8" title="1">if len(typeName) &gt; 65 </span><span class="cov8" title="1">{
                // Truncate if too long, but ensure it ends properly
                if baseType == "array" </span><span class="cov0" title="0">{
                        maxBase := 65 - 5 // Reserve 5 chars for "Array"
                        if maxBase &gt; 0 </span><span class="cov0" title="0">{
                                typeName = typeName[:maxBase] + "Array"
                        }</span> else<span class="cov0" title="0"> {
                                typeName = "GenArray"
                        }</span>
                } else<span class="cov8" title="1"> {
                        maxBase := 65 - 4 // Reserve 4 chars for "Type"
                        if maxBase &gt; 0 </span><span class="cov8" title="1">{
                                typeName = typeName[:maxBase] + "Type"
                        }</span> else<span class="cov0" title="0"> {
                                typeName = "GenType"
                        }</span>
                }
        }

        <span class="cov8" title="1">return typeName</span>
}

func generateStructureHash(structure map[string]string) string <span class="cov8" title="1">{
        // Create a consistent hash based on structure
        keys := make([]string, 0, len(structure))
        for key := range structure </span><span class="cov8" title="1">{
                keys = append(keys, key)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)

        var parts []string
        for _, key := range keys </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("%s:%s", key, structure[key]))
        }</span>

        <span class="cov8" title="1">content := strings.Join(parts, "|")
        hash := md5.Sum([]byte(content))
        return fmt.Sprintf("%x", hash)[:8]</span>
}

func generateArrayHash(itemType string) string <span class="cov8" title="1">{
        hash := md5.Sum([]byte("array_" + itemType))
        return fmt.Sprintf("%x", hash)[:8]
}</span>

func generateUniquePropertyID(name, propType string) string <span class="cov8" title="1">{
        cleanName := sanitizeID(name)

        // If propType is a custom type reference, extract a clean identifier
        if strings.HasPrefix(propType, "#/custom-types/") </span><span class="cov8" title="1">{
                // Extract the custom type ID from the reference
                parts := strings.Split(propType, "/")
                if len(parts) &gt;= 3 </span><span class="cov8" title="1">{
                        cleanType := sanitizeID(parts[len(parts)-1])
                        return fmt.Sprintf("%s_%s", cleanName, cleanType)
                }</span>
                // Fallback if parsing fails
                <span class="cov0" title="0">return fmt.Sprintf("%s_customtype", cleanName)</span>
        }

        // For primitive types, sanitize normally
        <span class="cov8" title="1">cleanType := sanitizeID(propType)
        return fmt.Sprintf("%s_%s", cleanName, cleanType)</span>
}

func (sa *SchemaAnalyzer) generateUniqueCustomTypeName(path, baseType string) string <span class="cov8" title="1">{
        baseName := generateCustomTypeName(path, baseType)

        // If the name is not used, return it
        if !sa.UsedCustomTypeNames[baseName] </span><span class="cov8" title="1">{
                sa.UsedCustomTypeNames[baseName] = true
                return baseName
        }</span>

        // If it's already used, add letter suffixes to maintain letter-only requirement
        <span class="cov8" title="1">letterSuffixes := []string{"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"}

        for _, suffix := range letterSuffixes </span><span class="cov8" title="1">{
                candidateName := baseName + suffix

                // Ensure it doesn't exceed 65 characters
                if len(candidateName) &gt; 65 </span><span class="cov0" title="0">{
                        // Truncate base name to make room for suffix
                        maxBaseLen := 65 - len(suffix)
                        if maxBaseLen &gt; 3 </span><span class="cov0" title="0">{ // Ensure minimum length
                                candidateName = baseName[:maxBaseLen] + suffix
                        }</span> else<span class="cov0" title="0"> {
                                candidateName = "GenType" + suffix
                        }</span>
                }

                <span class="cov8" title="1">if !sa.UsedCustomTypeNames[candidateName] </span><span class="cov8" title="1">{
                        sa.UsedCustomTypeNames[candidateName] = true
                        return candidateName
                }</span>
        }

        // If all single letters are used, try double letters
        <span class="cov0" title="0">for _, suffix1 := range letterSuffixes </span><span class="cov0" title="0">{
                for _, suffix2 := range letterSuffixes </span><span class="cov0" title="0">{
                        suffix := suffix1 + suffix2
                        candidateName := baseName + suffix

                        // Ensure it doesn't exceed 65 characters
                        if len(candidateName) &gt; 65 </span><span class="cov0" title="0">{
                                // Truncate base name to make room for suffix
                                maxBaseLen := 65 - len(suffix)
                                if maxBaseLen &gt; 3 </span><span class="cov0" title="0">{ // Ensure minimum length
                                        candidateName = baseName[:maxBaseLen] + suffix
                                }</span> else<span class="cov0" title="0"> {
                                        candidateName = "GenType" + suffix
                                }</span>
                        }

                        <span class="cov0" title="0">if !sa.UsedCustomTypeNames[candidateName] </span><span class="cov0" title="0">{
                                sa.UsedCustomTypeNames[candidateName] = true
                                return candidateName
                        }</span>
                }
        }

        // Fallback - this should rarely happen
        <span class="cov0" title="0">return "UniqueGenType"</span>
}

func (sa *SchemaAnalyzer) generateUniquePropertyID(name, propType string) string <span class="cov8" title="1">{
        baseID := generateUniquePropertyID(name, propType)

        // If the ID is not used, return it
        if !sa.UsedPropertyIDs[baseID] </span><span class="cov8" title="1">{
                sa.UsedPropertyIDs[baseID] = true
                return baseID
        }</span>

        // If it's already used, add a counter
        <span class="cov0" title="0">counter := 1
        for </span><span class="cov0" title="0">{
                candidateID := fmt.Sprintf("%s_%d", baseID, counter)
                if !sa.UsedPropertyIDs[candidateID] </span><span class="cov0" title="0">{
                        sa.UsedPropertyIDs[candidateID] = true
                        return candidateID
                }</span>
                <span class="cov0" title="0">counter++</span>
        }
}

func generateRandomID() string <span class="cov0" title="0">{
        const length = 10
        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        result := make([]byte, length)
        for i := range result </span><span class="cov0" title="0">{
                result[i] = charset[rand.Intn(len(charset))]
        }</span>
        <span class="cov0" title="0">return string(result)</span>
}

func sanitizeEventID(input string) string <span class="cov8" title="1">{
        // Remove or replace problematic characters
        result := input

        // Replace common problematic characters
        replacements := map[string]string{
                "/":  "_",
                "\\": "_",
                "?":  "_",
                "&lt;":  "_",
                "&gt;":  "_",
                "\"": "_",
                "'":  "_",
                "(":  "_",
                ")":  "_",
                "[":  "_",
                "]":  "_",
                "{":  "_",
                "}":  "_",
                "|":  "_",
                "#":  "_",
                "%":  "_",
                "&amp;":  "_",
                "*":  "_",
                "+":  "_",
                "=":  "_",
                "@":  "_",
                "!":  "_",
                " ":  "_",
                "\t": "_",
                "\n": "_",
                "\r": "_",
        }

        for old, new := range replacements </span><span class="cov8" title="1">{
                result = strings.ReplaceAll(result, old, new)
        }</span>

        // Remove any remaining non-alphanumeric characters except underscores and hyphens
        <span class="cov8" title="1">var clean strings.Builder
        for _, char := range result </span><span class="cov8" title="1">{
                if (char &gt;= 'a' &amp;&amp; char &lt;= 'z') ||
                        (char &gt;= 'A' &amp;&amp; char &lt;= 'Z') ||
                        (char &gt;= '0' &amp;&amp; char &lt;= '9') ||
                        char == '_' || char == '-' </span><span class="cov8" title="1">{
                        clean.WriteRune(char)
                }</span>
        }

        <span class="cov8" title="1">result = clean.String()

        // Remove consecutive underscores
        for strings.Contains(result, "__") </span><span class="cov0" title="0">{
                result = strings.ReplaceAll(result, "__", "_")
        }</span>

        // Trim underscores from start and end
        <span class="cov8" title="1">result = strings.Trim(result, "_")

        // Ensure lowercase for consistency
        result = strings.ToLower(result)

        return result</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package converter

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        yamlModels "github.com/rudderlabs/rudder-iac/cli/pkg/schema/models"
        "github.com/rudderlabs/rudder-iac/cli/pkg/schema/utils"
        "gopkg.in/yaml.v3"
)

// ConversionOptions holds configuration for the conversion process
type ConversionOptions struct {
        InputFile  string
        OutputDir  string
        DryRun     bool
        Verbose    bool
        YAMLIndent int
}

// ConversionResult holds the results of the conversion process
type ConversionResult struct {
        EventsCount      int
        PropertiesCount  int
        CustomTypesCount int
        TrackingPlans    []string
        GeneratedFiles   []string
}

// SchemaConverter handles the conversion of unflattened schemas to YAML files
type SchemaConverter struct {
        analyzer *SchemaAnalyzer
        options  ConversionOptions
}

// NewSchemaConverter creates a new schema converter
func NewSchemaConverter(options ConversionOptions) *SchemaConverter <span class="cov8" title="1">{
        // Set default YAML indent if not specified or invalid
        if options.YAMLIndent &lt;= 0 </span><span class="cov8" title="1">{
                options.YAMLIndent = 2
        }</span>

        <span class="cov8" title="1">return &amp;SchemaConverter{
                analyzer: NewSchemaAnalyzer(),
                options:  options,
        }</span>
}

// Convert performs the complete conversion process
func (sc *SchemaConverter) Convert() (*ConversionResult, error) <span class="cov8" title="1">{
        if sc.options.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("Starting conversion of %s to %s\n", sc.options.InputFile, sc.options.OutputDir)
        }</span>

        // Read and parse input file
        <span class="cov8" title="1">schemasFile, err := utils.ReadSchemasFile(sc.options.InputFile)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read input file: %w", err)
        }</span>

        <span class="cov8" title="1">if sc.options.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("Found %d schemas to analyze\n", len(schemasFile.Schemas))
        }</span>

        // Analyze schemas
        <span class="cov8" title="1">err = sc.analyzer.AnalyzeSchemas(schemasFile.Schemas)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to analyze schemas: %w", err)
        }</span>

        <span class="cov8" title="1">if sc.options.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("Analysis complete: %d events, %d properties, %d custom types\n",
                        len(sc.analyzer.Events), len(sc.analyzer.Properties), len(sc.analyzer.CustomTypes))
        }</span>

        // Generate YAML structures
        <span class="cov8" title="1">eventsYAML := sc.analyzer.GenerateEventsYAML()
        propertiesYAML := sc.analyzer.GeneratePropertiesYAML()
        customTypesYAML := sc.analyzer.GenerateCustomTypesYAML()
        trackingPlansYAML := sc.analyzer.GenerateTrackingPlansYAML(schemasFile.Schemas)

        result := &amp;ConversionResult{
                EventsCount:      len(eventsYAML.Spec.Events),
                PropertiesCount:  len(propertiesYAML.Spec.Properties),
                CustomTypesCount: len(customTypesYAML.Spec.Types),
        }

        if sc.options.DryRun </span><span class="cov8" title="1">{
                return sc.performDryRun(eventsYAML, propertiesYAML, customTypesYAML, trackingPlansYAML, result)
        }</span>

        // Create output directory
        <span class="cov8" title="1">err = os.MkdirAll(sc.options.OutputDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create output directory: %w", err)
        }</span>

        // Write YAML files
        <span class="cov8" title="1">err = sc.writeYAMLFiles(eventsYAML, propertiesYAML, customTypesYAML, trackingPlansYAML, result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write YAML files: %w", err)
        }</span>

        <span class="cov8" title="1">if sc.options.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("Conversion completed successfully!\n")
                fmt.Printf("Generated %d files in %s\n", len(result.GeneratedFiles), sc.options.OutputDir)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// performDryRun shows what would be generated without writing files
func (sc *SchemaConverter) performDryRun(eventsYAML *yamlModels.EventsYAML, propertiesYAML *yamlModels.PropertiesYAML,
        customTypesYAML *yamlModels.CustomTypesYAML, trackingPlansYAML map[string]*yamlModels.TrackingPlanYAML,
        result *ConversionResult) (*ConversionResult, error) <span class="cov8" title="1">{

        fmt.Printf("DRY RUN: Would generate the following files in %s:\n", sc.options.OutputDir)
        fmt.Printf("  ✓ events.yaml (%d events)\n", len(eventsYAML.Spec.Events))
        fmt.Printf("  ✓ properties.yaml (%d properties)\n", len(propertiesYAML.Spec.Properties))
        fmt.Printf("  ✓ custom-types.yaml (%d custom types)\n", len(customTypesYAML.Spec.Types))

        fmt.Printf("  ✓ tracking-plans/ directory\n")

        for writeKey := range trackingPlansYAML </span><span class="cov8" title="1">{
                planFile := fmt.Sprintf("writekey-%s.yaml", writeKey)
                fmt.Printf("    ✓ %s\n", planFile)
                result.TrackingPlans = append(result.TrackingPlans, planFile)
        }</span>

        <span class="cov8" title="1">if sc.options.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("\nDRY RUN: Preview of events.yaml:\n")
                sc.printYAMLPreview(eventsYAML, 3)

                fmt.Printf("\nDRY RUN: Preview of first few properties:\n")
                sc.printPropertiesPreview(propertiesYAML, 3)

                if len(customTypesYAML.Spec.Types) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("\nDRY RUN: Preview of first custom type:\n")
                        sc.printCustomTypesPreview(customTypesYAML, 1)
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// writeYAMLFiles writes all generated YAML files to disk
func (sc *SchemaConverter) writeYAMLFiles(eventsYAML *yamlModels.EventsYAML, propertiesYAML *yamlModels.PropertiesYAML,
        customTypesYAML *yamlModels.CustomTypesYAML, trackingPlansYAML map[string]*yamlModels.TrackingPlanYAML,
        result *ConversionResult) error <span class="cov8" title="1">{

        // Write events.yaml
        eventsFile := filepath.Join(sc.options.OutputDir, "events.yaml")
        err := sc.writeYAMLFile(eventsFile, eventsYAML)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write events.yaml: %w", err)
        }</span>
        <span class="cov8" title="1">result.GeneratedFiles = append(result.GeneratedFiles, eventsFile)

        // Write properties.yaml
        propertiesFile := filepath.Join(sc.options.OutputDir, "properties.yaml")
        err = sc.writeYAMLFile(propertiesFile, propertiesYAML)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write properties.yaml: %w", err)
        }</span>
        <span class="cov8" title="1">result.GeneratedFiles = append(result.GeneratedFiles, propertiesFile)

        // Write custom-types.yaml
        customTypesFile := filepath.Join(sc.options.OutputDir, "custom-types.yaml")
        err = sc.writeYAMLFile(customTypesFile, customTypesYAML)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write custom-types.yaml: %w", err)
        }</span>
        <span class="cov8" title="1">result.GeneratedFiles = append(result.GeneratedFiles, customTypesFile)

        // Create tracking-plans directory
        trackingPlansDir := filepath.Join(sc.options.OutputDir, "tracking-plans")
        err = os.MkdirAll(trackingPlansDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create tracking-plans directory: %w", err)
        }</span>

        // Write tracking plan files
        <span class="cov8" title="1">for writeKey, trackingPlan := range trackingPlansYAML </span><span class="cov8" title="1">{
                planFile := filepath.Join(trackingPlansDir, fmt.Sprintf("writekey-%s.yaml", writeKey))
                err = sc.writeYAMLFile(planFile, trackingPlan)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write tracking plan %s: %w", planFile, err)
                }</span>
                <span class="cov8" title="1">result.GeneratedFiles = append(result.GeneratedFiles, planFile)
                result.TrackingPlans = append(result.TrackingPlans, fmt.Sprintf("writekey-%s.yaml", writeKey))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// writeYAMLFile writes a YAML structure to a file
func (sc *SchemaConverter) writeYAMLFile(filename string, data interface{}) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create file %s: %w", filename, err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        encoder := yaml.NewEncoder(file)
        encoder.SetIndent(sc.options.YAMLIndent)
        defer encoder.Close()

        err = encoder.Encode(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode YAML to %s: %w", filename, err)
        }</span>

        <span class="cov8" title="1">if sc.options.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("  ✓ Created %s\n", filename)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// printYAMLPreview prints a preview of YAML content
func (sc *SchemaConverter) printYAMLPreview(data interface{}, maxItems int) <span class="cov0" title="0">{
        yamlData, err := yaml.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error generating preview: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">lines := strings.Split(string(yamlData), "\n")
        count := 0
        for _, line := range lines </span><span class="cov0" title="0">{
                if count &gt;= 20 </span><span class="cov0" title="0">{ // Limit preview length
                        fmt.Printf("    ... (truncated)\n")
                        break</span>
                }
                <span class="cov0" title="0">fmt.Printf("    %s\n", line)
                count++</span>
        }
}

// printPropertiesPreview prints a preview of properties
func (sc *SchemaConverter) printPropertiesPreview(propertiesYAML *yamlModels.PropertiesYAML, maxItems int) <span class="cov0" title="0">{
        fmt.Printf("    version: %s\n", propertiesYAML.Version)
        fmt.Printf("    kind: %s\n", propertiesYAML.Kind)
        fmt.Printf("    spec:\n")
        fmt.Printf("      properties:\n")

        count := 0
        for _, prop := range propertiesYAML.Spec.Properties </span><span class="cov0" title="0">{
                if count &gt;= maxItems </span><span class="cov0" title="0">{
                        fmt.Printf("        ... (showing %d of %d properties)\n", maxItems, len(propertiesYAML.Spec.Properties))
                        break</span>
                }
                <span class="cov0" title="0">fmt.Printf("        - id: %s\n", prop.ID)
                fmt.Printf("          name: %s\n", prop.Name)
                fmt.Printf("          type: %s\n", prop.Type)
                if prop.Description != "" </span><span class="cov0" title="0">{
                        fmt.Printf("          description: %s\n", prop.Description)
                }</span>
                <span class="cov0" title="0">count++</span>
        }
}

// printCustomTypesPreview prints a preview of custom types
func (sc *SchemaConverter) printCustomTypesPreview(customTypesYAML *yamlModels.CustomTypesYAML, maxItems int) <span class="cov0" title="0">{
        fmt.Printf("    version: %s\n", customTypesYAML.Version)
        fmt.Printf("    kind: %s\n", customTypesYAML.Kind)
        fmt.Printf("    spec:\n")
        fmt.Printf("      types:\n")

        count := 0
        for _, customType := range customTypesYAML.Spec.Types </span><span class="cov0" title="0">{
                if count &gt;= maxItems </span><span class="cov0" title="0">{
                        fmt.Printf("        ... (showing %d of %d custom types)\n", maxItems, len(customTypesYAML.Spec.Types))
                        break</span>
                }
                <span class="cov0" title="0">fmt.Printf("        - id: %s\n", customType.ID)
                fmt.Printf("          name: %s\n", customType.Name)
                fmt.Printf("          type: %s\n", customType.Type)
                if customType.Description != "" </span><span class="cov0" title="0">{
                        fmt.Printf("          description: %s\n", customType.Description)
                }</span>
                <span class="cov0" title="0">count++</span>
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package converter

import (
        "fmt"
        "sort"
        "strings"

        internalModels "github.com/rudderlabs/rudder-iac/cli/internal/schema/models"
        yamlModels "github.com/rudderlabs/rudder-iac/cli/pkg/schema/models"
)

// GenerateEventsYAML creates the events.yaml structure
func (sa *SchemaAnalyzer) GenerateEventsYAML() *yamlModels.EventsYAML <span class="cov8" title="1">{
        var events []yamlModels.EventDefinition

        // Sort events by ID for consistent output
        var eventKeys []string
        for key := range sa.Events </span><span class="cov8" title="1">{
                eventKeys = append(eventKeys, key)
        }</span>
        <span class="cov8" title="1">sort.Strings(eventKeys)

        for _, key := range eventKeys </span><span class="cov8" title="1">{
                eventInfo := sa.Events[key]
                event := yamlModels.EventDefinition{
                        ID:          eventInfo.ID,
                        Name:        eventInfo.Name,
                        EventType:   eventInfo.EventType,
                        Description: eventInfo.Description,
                }
                events = append(events, event)
        }</span>

        <span class="cov8" title="1">return &amp;yamlModels.EventsYAML{
                Version: "rudder/0.1",
                Kind:    "events",
                Metadata: yamlModels.YAMLMetadata{
                        Name: "extracted_events",
                },
                Spec: yamlModels.EventsSpec{
                        Events: events,
                },
        }</span>
}

// GeneratePropertiesYAML creates the properties.yaml structure
func (sa *SchemaAnalyzer) GeneratePropertiesYAML() *yamlModels.PropertiesYAML <span class="cov8" title="1">{
        var properties []yamlModels.PropertyDefinition

        // Sort properties by path for consistent output
        var propertyKeys []string
        for key := range sa.Properties </span><span class="cov8" title="1">{
                propertyKeys = append(propertyKeys, key)
        }</span>
        <span class="cov8" title="1">sort.Strings(propertyKeys)

        for _, key := range propertyKeys </span><span class="cov8" title="1">{
                propertyInfo := sa.Properties[key]
                property := yamlModels.PropertyDefinition{
                        ID:          propertyInfo.ID,
                        Name:        propertyInfo.Name,
                        Type:        propertyInfo.Type,
                        Description: propertyInfo.Description,
                }
                properties = append(properties, property)
        }</span>

        <span class="cov8" title="1">return &amp;yamlModels.PropertiesYAML{
                Version: "rudder/v0.1",
                Kind:    "properties",
                Metadata: yamlModels.YAMLMetadata{
                        Name: "extracted_properties",
                },
                Spec: yamlModels.PropertiesSpec{
                        Properties: properties,
                },
        }</span>
}

// GenerateCustomTypesYAML creates the custom-types.yaml structure
func (sa *SchemaAnalyzer) GenerateCustomTypesYAML() *yamlModels.CustomTypesYAML <span class="cov8" title="1">{
        var customTypes []yamlModels.CustomTypeDefinition

        // Sort custom types by ID for consistent output
        var typeKeys []string
        for key := range sa.CustomTypes </span><span class="cov8" title="1">{
                typeKeys = append(typeKeys, key)
        }</span>
        <span class="cov8" title="1">sort.Strings(typeKeys)

        for _, key := range typeKeys </span><span class="cov8" title="1">{
                typeInfo := sa.CustomTypes[key]

                customType := yamlModels.CustomTypeDefinition{
                        ID:          typeInfo.ID,
                        Name:        typeInfo.Name,
                        Type:        typeInfo.Type,
                        Description: typeInfo.Description,
                }

                // Add configuration based on type
                if typeInfo.Type == "array" </span><span class="cov8" title="1">{
                        customType.Config = &amp;yamlModels.CustomTypeConfig{
                                ItemTypes: []string{typeInfo.ArrayItemType},
                        }
                }</span>

                // Add property references for object types
                <span class="cov8" title="1">if typeInfo.Type == "object" &amp;&amp; len(typeInfo.Structure) &gt; 0 </span><span class="cov8" title="1">{
                        var propertyRefs []yamlModels.PropertyRef

                        // Sort structure keys for consistent output
                        var structKeys []string
                        for structKey := range typeInfo.Structure </span><span class="cov8" title="1">{
                                structKeys = append(structKeys, structKey)
                        }</span>
                        <span class="cov8" title="1">sort.Strings(structKeys)

                        for _, structKey := range structKeys </span><span class="cov8" title="1">{
                                // Find the corresponding property
                                propertyID := findPropertyForStructField(sa, structKey, typeInfo)
                                if propertyID != "" </span><span class="cov8" title="1">{
                                        propertyRef := yamlModels.PropertyRef{
                                                Ref:      fmt.Sprintf("#/properties/extracted_properties/%s", propertyID),
                                                Required: false, // Default to optional
                                        }
                                        propertyRefs = append(propertyRefs, propertyRef)
                                }</span>
                        }

                        <span class="cov8" title="1">if len(propertyRefs) &gt; 0 </span><span class="cov8" title="1">{
                                customType.Properties = propertyRefs
                        }</span>
                }

                <span class="cov8" title="1">customTypes = append(customTypes, customType)</span>
        }

        <span class="cov8" title="1">return &amp;yamlModels.CustomTypesYAML{
                Version: "rudder/v0.1",
                Kind:    "custom-types",
                Metadata: yamlModels.YAMLMetadata{
                        Name: "extracted_custom_types",
                },
                Spec: yamlModels.CustomTypesSpec{
                        Types: customTypes,
                },
        }</span>
}

// GenerateTrackingPlansYAML creates tracking plan YAML structures grouped by writeKey
func (sa *SchemaAnalyzer) GenerateTrackingPlansYAML(schemas []internalModels.Schema) map[string]*yamlModels.TrackingPlanYAML <span class="cov8" title="1">{
        // Group schemas by writeKey
        writeKeyGroups := make(map[string][]internalModels.Schema)
        for _, schema := range schemas </span><span class="cov8" title="1">{
                writeKey := schema.WriteKey
                writeKeyGroups[writeKey] = append(writeKeyGroups[writeKey], schema)
        }</span>

        <span class="cov8" title="1">trackingPlans := make(map[string]*yamlModels.TrackingPlanYAML)

        // Keep track of used rule IDs globally to ensure uniqueness
        usedRuleIDs := make(map[string]bool)

        for writeKey, groupSchemas := range writeKeyGroups </span><span class="cov8" title="1">{
                planID := fmt.Sprintf("tracking_plan_%s", sanitizeID(writeKey))
                displayName := fmt.Sprintf("Tracking Plan for WriteKey %s", writeKey)

                var rules []yamlModels.EventRule

                // Create rules for each schema in the group
                for i, schema := range groupSchemas </span><span class="cov8" title="1">{
                        // Find the actual event ID that was created for this schema
                        eventID := sa.findEventIDForSchema(schema)

                        // Skip if no event was created for this schema (e.g., due to filtering)
                        if eventID == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Generate globally unique rule ID
                        <span class="cov8" title="1">ruleID := generateUniqueRuleID(writeKey, eventID, i, usedRuleIDs)

                        // Get properties for this schema
                        properties := sa.extractPropertiesForSchema(schema)

                        rule := yamlModels.EventRule{
                                Type: "event_rule",
                                ID:   ruleID,
                                Event: yamlModels.EventRuleRef{
                                        Ref:            fmt.Sprintf("#/events/extracted_events/%s", eventID),
                                        AllowUnplanned: false,
                                },
                                Properties: properties,
                        }

                        rules = append(rules, rule)</span>
                }

                <span class="cov8" title="1">trackingPlan := &amp;yamlModels.TrackingPlanYAML{
                        Version: "rudder/0.1",
                        Kind:    "tp",
                        Metadata: yamlModels.YAMLMetadata{
                                Name: planID,
                        },
                        Spec: yamlModels.TrackingPlanSpec{
                                ID:          planID,
                                DisplayName: displayName,
                                Description: fmt.Sprintf("Auto-generated tracking plan for writeKey: %s", writeKey),
                                Rules:       rules,
                        },
                }

                trackingPlans[writeKey] = trackingPlan</span>
        }

        <span class="cov8" title="1">return trackingPlans</span>
}

// extractPropertiesForSchema extracts property references for a specific schema
func (sa *SchemaAnalyzer) extractPropertiesForSchema(schema internalModels.Schema) []yamlModels.PropertyRuleRef <span class="cov8" title="1">{
        var properties []yamlModels.PropertyRuleRef

        // Recursively collect all property paths from the schema
        propertyPaths := sa.collectPropertyPaths(schema.Schema, "")

        // Sort for consistent output
        sort.Strings(propertyPaths)

        for _, path := range propertyPaths </span><span class="cov8" title="1">{
                // Find the property in our analyzed properties
                propertyKey := sa.findPropertyKeyForPath(path)
                if propertyKey != "" </span><span class="cov8" title="1">{
                        propertyInfo := sa.Properties[propertyKey]
                        propertyRef := yamlModels.PropertyRuleRef{
                                Ref:      fmt.Sprintf("#/properties/extracted_properties/%s", propertyInfo.ID),
                                Required: sa.isPropertyRequired(path), // Basic heuristic
                        }
                        properties = append(properties, propertyRef)
                }</span>
        }

        <span class="cov8" title="1">return properties</span>
}

// collectPropertyPaths recursively collects all property paths from a schema
func (sa *SchemaAnalyzer) collectPropertyPaths(obj interface{}, path string) []string <span class="cov8" title="1">{
        var paths []string

        switch v := obj.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                for key, value := range v </span><span class="cov8" title="1">{
                        fieldPath := buildPath(path, key)
                        paths = append(paths, fieldPath)

                        // Recursively collect from nested structures
                        nestedPaths := sa.collectPropertyPaths(value, fieldPath)
                        paths = append(paths, nestedPaths...)
                }</span>
        case []interface{}:<span class="cov8" title="1">
                // For arrays, we don't add the array itself as a path,
                // but we analyze the items
                if len(v) &gt; 0 </span><span class="cov8" title="1">{
                        nestedPaths := sa.collectPropertyPaths(v[0], path+"_item")
                        paths = append(paths, nestedPaths...)
                }</span>
        }

        <span class="cov8" title="1">return paths</span>
}

// findPropertyKeyForPath finds the property key for a given path
func (sa *SchemaAnalyzer) findPropertyKeyForPath(path string) string <span class="cov8" title="1">{
        // Try to find exact match first
        for key, property := range sa.Properties </span><span class="cov8" title="1">{
                if property.Path == path </span><span class="cov8" title="1">{
                        return key
                }</span>
        }

        // Try to find by property name
        <span class="cov8" title="1">propertyName := extractPropertyName(path)
        for key, property := range sa.Properties </span><span class="cov8" title="1">{
                if property.Name == propertyName </span><span class="cov8" title="1">{
                        return key
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// isPropertyRequired determines if a property should be marked as required
func (sa *SchemaAnalyzer) isPropertyRequired(path string) bool <span class="cov8" title="1">{
        // Basic heuristic: common required fields
        requiredFields := map[string]bool{
                "userId":      true,
                "anonymousId": true,
                "event":       true,
                "messageId":   true,
                "type":        true,
        }

        propertyName := extractPropertyName(path)
        return requiredFields[propertyName]
}</span>

// findPropertyForStructField finds the property ID for a structure field
func findPropertyForStructField(sa *SchemaAnalyzer, fieldName string, typeInfo *CustomTypeInfo) string <span class="cov8" title="1">{
        // Look for properties that match the field name in the context of the custom type path
        for _, property := range sa.Properties </span><span class="cov8" title="1">{
                // Check if the property path ends with the field name
                // This handles nested paths like "properties.user.name" matching field "name"
                pathParts := strings.Split(property.Path, ".")
                if len(pathParts) &gt; 0 &amp;&amp; pathParts[len(pathParts)-1] == fieldName </span><span class="cov8" title="1">{
                        return property.ID
                }</span>

                // Also check if the property name matches
                <span class="cov8" title="1">if property.Name == fieldName </span><span class="cov0" title="0">{
                        return property.ID
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// generateUniqueRuleID generates globally unique rule IDs across all tracking plans
func generateUniqueRuleID(writeKey, eventID string, index int, usedRuleIDs map[string]bool) string <span class="cov8" title="1">{
        sanitizedWriteKey := sanitizeID(writeKey)

        // Try the basic pattern first
        baseRuleID := fmt.Sprintf("%s_%s_rule", sanitizedWriteKey, eventID)

        // If it's not used, return it
        if !usedRuleIDs[baseRuleID] </span><span class="cov8" title="1">{
                usedRuleIDs[baseRuleID] = true
                return baseRuleID
        }</span>

        // If the base ID is already used, add index to make it unique
        <span class="cov8" title="1">var finalRuleID string
        counter := index
        for </span><span class="cov8" title="1">{
                finalRuleID = fmt.Sprintf("%s_%s_rule_%d", sanitizedWriteKey, eventID, counter)
                if !usedRuleIDs[finalRuleID] </span><span class="cov8" title="1">{
                        usedRuleIDs[finalRuleID] = true
                        break</span>
                }
                <span class="cov0" title="0">counter++</span>
        }

        <span class="cov8" title="1">return finalRuleID</span>
}

// findEventIDForSchema finds the event ID that was created for a given schema
func (sa *SchemaAnalyzer) findEventIDForSchema(schema internalModels.Schema) string <span class="cov8" title="1">{
        // Look through all events to find the one that matches this schema
        for _, event := range sa.Events </span><span class="cov8" title="1">{
                if event.Original.EventIdentifier == schema.EventIdentifier &amp;&amp;
                        event.Original.WriteKey == schema.WriteKey </span><span class="cov8" title="1">{
                        return event.ID
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package unflatten

import (
        "strconv"
        "strings"
)

// UnflattenSchema converts a flattened schema map to a nested structure
func UnflattenSchema(flattened map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        result := make(map[string]interface{})

        for key, value := range flattened </span><span class="cov8" title="1">{
                setNestedValue(result, strings.Split(key, "."), value)
        }</span>

        <span class="cov8" title="1">return result</span>
}

// setNestedValue recursively sets a value in a nested structure
func setNestedValue(obj map[string]interface{}, path []string, value interface{}) <span class="cov8" title="1">{
        if len(path) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if len(path) == 1 </span><span class="cov8" title="1">{
                // Last element in path - set the value
                obj[path[0]] = value
                return
        }</span>

        <span class="cov8" title="1">currentKey := path[0]
        remainingPath := path[1:]
        nextKey := remainingPath[0]

        // Check if next key is a numeric index (array)
        if isNumericIndex(nextKey) </span><span class="cov8" title="1">{
                // Current key should point to an array
                if obj[currentKey] == nil </span><span class="cov8" title="1">{
                        obj[currentKey] = make([]interface{}, 0)
                }</span>

                // Ensure it's an array
                <span class="cov8" title="1">arr, ok := obj[currentKey].([]interface{})
                if !ok </span><span class="cov8" title="1">{
                        arr = make([]interface{}, 0)
                        obj[currentKey] = arr
                }</span>

                // Set value in array
                <span class="cov8" title="1">setArrayValue(&amp;arr, remainingPath, value)
                obj[currentKey] = arr</span>
        } else<span class="cov8" title="1"> {
                // Current key should point to an object
                if obj[currentKey] == nil </span><span class="cov8" title="1">{
                        obj[currentKey] = make(map[string]interface{})
                }</span>

                // Ensure it's a map
                <span class="cov8" title="1">nestedObj, ok := obj[currentKey].(map[string]interface{})
                if !ok </span><span class="cov8" title="1">{
                        nestedObj = make(map[string]interface{})
                        obj[currentKey] = nestedObj
                }</span>

                // Recursively set the value
                <span class="cov8" title="1">setNestedValue(nestedObj, remainingPath, value)</span>
        }
}

// setArrayValue sets a value in an array at the specified index path
func setArrayValue(arr *[]interface{}, path []string, value interface{}) <span class="cov8" title="1">{
        if len(path) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">indexStr := path[0]
        index, err := strconv.Atoi(indexStr)
        if err != nil </span><span class="cov0" title="0">{
                return // Invalid index
        }</span>

        // Expand array if necessary
        <span class="cov8" title="1">for len(*arr) &lt;= index </span><span class="cov8" title="1">{
                *arr = append(*arr, nil)
        }</span>

        <span class="cov8" title="1">if len(path) == 1 </span><span class="cov8" title="1">{
                // Last element - set the value
                (*arr)[index] = value
                return
        }</span>

        // More path elements remain
        <span class="cov8" title="1">remainingPath := path[1:]
        nextKey := remainingPath[0]

        if isNumericIndex(nextKey) </span><span class="cov8" title="1">{
                // Next level is also an array
                if (*arr)[index] == nil </span><span class="cov8" title="1">{
                        (*arr)[index] = make([]interface{}, 0)
                }</span>

                <span class="cov8" title="1">nestedArr, ok := (*arr)[index].([]interface{})
                if !ok </span><span class="cov0" title="0">{
                        nestedArr = make([]interface{}, 0)
                        (*arr)[index] = nestedArr
                }</span>

                <span class="cov8" title="1">setArrayValue(&amp;nestedArr, remainingPath, value)
                (*arr)[index] = nestedArr</span>
        } else<span class="cov8" title="1"> {
                // Next level is an object
                if (*arr)[index] == nil </span><span class="cov8" title="1">{
                        (*arr)[index] = make(map[string]interface{})
                }</span>

                <span class="cov8" title="1">nestedObj, ok := (*arr)[index].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        nestedObj = make(map[string]interface{})
                        (*arr)[index] = nestedObj
                }</span>

                <span class="cov8" title="1">setNestedValue(nestedObj, remainingPath, value)</span>
        }
}

// isNumericIndex checks if a string represents a numeric array index
func isNumericIndex(s string) bool <span class="cov8" title="1">{
        _, err := strconv.Atoi(s)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package differ

import (
        "reflect"

        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
        "github.com/samber/lo"
)

var (
        isNilTypes = []reflect.Kind{reflect.Map, reflect.Slice, reflect.Pointer}
)

// Diff represents the differences between two resource graphs
type Diff struct {
        // NewResources contains URNs of resources that exist in target but not in source
        NewResources []string
        // UpdatedResources contains URNs of resources that exist in both graphs but have different data
        UpdatedResources map[string]ResourceDiff
        // RemovedResources contains URNs of resources that exist in source but not in target
        RemovedResources []string
        // UnmodifiedResources contains URNs of resources that exist in both graphs with identical data
        UnmodifiedResources []string
}

type ResourceDiff struct {
        URN   string
        Diffs map[string]PropertyDiff
}

type PropertyDiff struct {
        Property    string
        SourceValue interface{}
        TargetValue interface{}
}

// ComputeDiff computes the diff between two graphs
// It returns a Diff struct containing the new, updated, removed and unmodified resources
// - New resources are resources that exist in the target but not in the source
// - Updated resources are resources that exist in both but their data differ
// - Removed resources are resources that exist in the source but not in the target
// - Unmodified resources are resources that exist in both with identical data
func ComputeDiff(source *resources.Graph, target *resources.Graph) *Diff <span class="cov8" title="1">{
        newResources := []string{}
        removedResources := []string{}
        updatedResources := map[string]ResourceDiff{}
        unmodifiedResources := []string{}

        // Iterate over target resources to find new and updated resources
        for urn, r := range target.Resources() </span><span class="cov8" title="1">{
                if sourceResource, exists := source.GetResource(urn); !exists </span><span class="cov8" title="1">{
                        // Resource is new if it doesn't exist in the source
                        newResources = append(newResources, urn)
                }</span> else<span class="cov8" title="1"> {
                        // Check if resource is updated or unmodified
                        propertyDiffs := CompareData(sourceResource.Data(), r.Data())
                        if len(propertyDiffs) &gt; 0 </span><span class="cov8" title="1">{
                                updatedResources[urn] = ResourceDiff{URN: urn, Diffs: propertyDiffs}
                        }</span> else<span class="cov8" title="1"> {
                                unmodifiedResources = append(unmodifiedResources, urn)
                        }</span>
                }
        }

        // Iterate over source resources to find removed resources
        <span class="cov8" title="1">for urn := range source.Resources() </span><span class="cov8" title="1">{
                if _, exists := target.GetResource(urn); !exists </span><span class="cov8" title="1">{
                        // Resource is removed if it doesn't exist in the target
                        removedResources = append(removedResources, urn)
                }</span>
        }

        <span class="cov8" title="1">return &amp;Diff{
                NewResources:        newResources,
                UpdatedResources:    updatedResources,
                RemovedResources:    removedResources,
                UnmodifiedResources: unmodifiedResources,
        }</span>
}

// compareData compares the data of two resources and returns the differences
func CompareData(r1, r2 resources.ResourceData) map[string]PropertyDiff <span class="cov8" title="1">{
        diffs := make(map[string]PropertyDiff)

        // Helper function to compare values recursively
        var compareValues func(key string, v1, v2 interface{})
        compareValues = func(key string, v1, v2 interface{}) </span><span class="cov8" title="1">{

                if isNil(v1) &amp;&amp; isNil(v2) </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">newV1, ok := rewriteCompatibleType(v1)
                if ok </span><span class="cov0" title="0">{
                        v1 = newV1
                }</span>

                <span class="cov8" title="1">if reflect.TypeOf(v1) != reflect.TypeOf(v2) </span><span class="cov0" title="0">{
                        diffs[key] = PropertyDiff{Property: key, SourceValue: v1, TargetValue: v2}
                        return
                }</span>

                <span class="cov8" title="1">switch v1Typed := v1.(type) </span>{

                case []map[string]interface{}:<span class="cov0" title="0">
                        v2Typed := v2.([]map[string]interface{})
                        if len(v1Typed) != len(v2Typed) </span><span class="cov0" title="0">{
                                diffs[key] = PropertyDiff{Property: key, SourceValue: v1, TargetValue: v2}
                                return
                        }</span>
                        <span class="cov0" title="0">for i := range v1Typed </span><span class="cov0" title="0">{
                                compareValues(key, v1Typed[i], v2Typed[i])
                        }</span>

                case map[string]interface{}:<span class="cov0" title="0">
                        v2Typed := v2.(map[string]interface{})
                        subDiffs := CompareData(v1Typed, v2Typed)
                        if len(subDiffs) &gt; 0 </span><span class="cov0" title="0">{
                                diffs[key] = PropertyDiff{Property: key, SourceValue: v1, TargetValue: v2}
                        }</span>
                case []interface{}:<span class="cov0" title="0">
                        v2Typed := v2.([]interface{})
                        if len(v1Typed) != len(v2Typed) </span><span class="cov0" title="0">{
                                diffs[key] = PropertyDiff{Property: key, SourceValue: v1, TargetValue: v2}
                                return
                        }</span>
                        <span class="cov0" title="0">for i := range v1Typed </span><span class="cov0" title="0">{
                                compareValues(key, v1Typed[i], v2Typed[i])
                        }</span>
                default:<span class="cov8" title="1">
                        if v1 != v2 </span><span class="cov8" title="1">{
                                diffs[key] = PropertyDiff{Property: key, SourceValue: v1, TargetValue: v2}
                        }</span>
                }
        }

        // Iterate over properties in r1 to find differences
        <span class="cov8" title="1">for key, value1 := range r1 </span><span class="cov8" title="1">{
                if value2, exists := r2[key]; !exists </span><span class="cov8" title="1">{
                        diffs[key] = PropertyDiff{Property: key, SourceValue: value1, TargetValue: nil}
                }</span> else<span class="cov8" title="1"> {
                        compareValues(key, value1, value2)
                }</span>
        }

        // Iterate over properties in r2 to find properties that are not in r1
        <span class="cov8" title="1">for key, value2 := range r2 </span><span class="cov8" title="1">{
                if _, exists := r1[key]; !exists </span><span class="cov8" title="1">{
                        diffs[key] = PropertyDiff{Property: key, SourceValue: nil, TargetValue: value2}
                }</span>
        }

        <span class="cov8" title="1">return diffs</span>
}

// rewrite []interface{} -&gt;  map[string]interface{} if possible
// and return back the response.
func rewriteCompatibleType(input interface{}) (interface{}, bool) <span class="cov8" title="1">{

        if _, ok := input.([]interface{}); !ok </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov0" title="0">slice := input.([]interface{})

        output := make([]map[string]interface{}, len(slice))
        for i, item := range slice </span><span class="cov0" title="0">{
                if _, ok := item.(map[string]interface{}); !ok </span><span class="cov0" title="0">{
                        return nil, false
                }</span>
                <span class="cov0" title="0">output[i] = item.(map[string]interface{})</span>
        }

        <span class="cov0" title="0">return output, true</span>
}

func isNil(val interface{}) bool <span class="cov8" title="1">{
        if val == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if lo.Contains(isNilTypes, reflect.ValueOf(val).Kind()) </span><span class="cov0" title="0">{
                return reflect.ValueOf(val).IsNil()
        }</span>

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package differ

import (
        "fmt"
        "reflect"

        "github.com/rudderlabs/rudder-iac/cli/internal/ui"
)

func PrintDiff(diff *Diff) <span class="cov0" title="0">{
        if len(diff.NewResources) &gt; 0 </span><span class="cov0" title="0">{
                listResources("New resources", diff.NewResources, nil)
        }</span>

        <span class="cov0" title="0">if len(diff.UpdatedResources) &gt; 0 </span><span class="cov0" title="0">{
                urns := []string{}
                for _, r := range diff.UpdatedResources </span><span class="cov0" title="0">{
                        urns = append(urns, r.URN)
                }</span>
                <span class="cov0" title="0">listResources("Updated resources", urns, func(urn string) string </span><span class="cov0" title="0">{
                        r := diff.UpdatedResources[urn]
                        details := ""
                        for _, d := range r.Diffs </span><span class="cov0" title="0">{
                                details += fmt.Sprintf(
                                        "    - %s: %s %s %s\n",
                                        ui.Color(d.Property, ui.White),
                                        printable(d.SourceValue),
                                        ui.Color("=&gt;", ui.Yellow),
                                        printable(d.TargetValue),
                                )
                        }</span>
                        <span class="cov0" title="0">return details</span>
                })
        }

        <span class="cov0" title="0">if len(diff.RemovedResources) &gt; 0 </span><span class="cov0" title="0">{
                listResources("Removed resources", diff.RemovedResources, nil)
        }</span>
}

func listResources(label string, resources []string, detailFn func(string) string) <span class="cov0" title="0">{
        fmt.Println(ui.Bold(label) + ":")
        for _, urn := range resources </span><span class="cov0" title="0">{
                fmt.Printf("  - %s\n", ui.Color(urn, ui.White))
                if detailFn != nil </span><span class="cov0" title="0">{
                        fmt.Printf("%s\n", detailFn(urn))
                }</span>
        }
        <span class="cov0" title="0">fmt.Println()</span>
}

func printable(val interface{}) string <span class="cov0" title="0">{
        if val == nil </span><span class="cov0" title="0">{
                return ui.Color("&lt;nil&gt;", ui.Blue)
        }</span>

        <span class="cov0" title="0">if reflect.ValueOf(val).Kind() == reflect.Pointer </span><span class="cov0" title="0">{
                return fmt.Sprintf("%v", reflect.ValueOf(val).Elem())
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%v", val)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package planner

import (
        "fmt"
        "slices"
        "sort"

        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/differ"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
)

type Planner struct {
}

type OperationType int

const (
        Create OperationType = iota
        Update
        Delete
)

type Operation struct {
        Type     OperationType
        Resource *resources.Resource
}

func (o *Operation) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s %s", o.Type.String(), o.Resource.URN())
}</span>

func (t *OperationType) String() string <span class="cov0" title="0">{
        switch *t </span>{
        case Create:<span class="cov0" title="0">
                return "Create"</span>
        case Update:<span class="cov0" title="0">
                return "Update"</span>
        case Delete:<span class="cov0" title="0">
                return "Delete"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

type Plan struct {
        Diff       *differ.Diff
        Operations []*Operation
}

func New() *Planner <span class="cov8" title="1">{
        return &amp;Planner{}
}</span>

func (p *Planner) Plan(source, target *resources.Graph) *Plan <span class="cov8" title="1">{
        diff := differ.ComputeDiff(source, target)
        plan := &amp;Plan{
                Diff: diff,
        }

        sortedNew := sortByDependencies(diff.NewResources, target)
        for _, urn := range sortedNew </span><span class="cov8" title="1">{
                resource, _ := target.GetResource(urn)
                plan.Operations = append(plan.Operations, &amp;Operation{Type: Create, Resource: resource})
        }</span>

        <span class="cov8" title="1">updatedURNs := make([]string, 0, len(diff.UpdatedResources))
        for r := range diff.UpdatedResources </span><span class="cov8" title="1">{
                updatedURNs = append(updatedURNs, r)
        }</span>
        <span class="cov8" title="1">sortedUpdated := sortByDependencies(updatedURNs, target)
        for _, urn := range sortedUpdated </span><span class="cov8" title="1">{
                resource, _ := target.GetResource(urn)
                plan.Operations = append(plan.Operations, &amp;Operation{Type: Update, Resource: resource})
        }</span>

        <span class="cov8" title="1">sortedDeleted := sortByDependencies(diff.RemovedResources, source)
        slices.Reverse(sortedDeleted)
        for _, urn := range sortedDeleted </span><span class="cov8" title="1">{
                resource, _ := source.GetResource(urn)
                plan.Operations = append(plan.Operations, &amp;Operation{Type: Delete, Resource: resource})
        }</span>

        <span class="cov8" title="1">return plan</span>
}

// sortByDependencies returns resources ordered by their dependencies,
// so that resources that depend on others are visited after their dependencies.
// Resources with the same dependencies are sorted alphabetically for consistent ordering.
func sortByDependencies(urns []string, g *resources.Graph) []string <span class="cov8" title="1">{
        // Sort URNs alphabetically first
        sort.Strings(urns)

        visited := make(map[string]bool)
        sorted := make([]string, 0, len(urns))

        var visit func(string)
        visit = func(urn string) </span><span class="cov8" title="1">{
                if visited[urn] </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">visited[urn] = true

                for _, dep := range g.GetDependencies(urn) </span><span class="cov8" title="1">{
                        // Only visit dependencies that are in our target URN set
                        for _, targetURN := range urns </span><span class="cov8" title="1">{
                                if dep == targetURN </span><span class="cov8" title="1">{
                                        visit(dep)
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">sorted = append(sorted, urn)</span>
        }

        <span class="cov8" title="1">for _, urn := range urns </span><span class="cov8" title="1">{
                visit(urn)
        }</span>

        <span class="cov8" title="1">return sorted</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package resources

type Graph struct {
        resources    map[string]*Resource
        dependencies map[string][]string
}

func NewGraph() *Graph <span class="cov8" title="1">{
        return &amp;Graph{
                resources:    map[string]*Resource{},
                dependencies: map[string][]string{},
        }
}</span>

func (s *Graph) Resources() map[string]*Resource <span class="cov8" title="1">{
        return s.resources
}</span>

func (s *Graph) AddResource(r *Resource) <span class="cov8" title="1">{
        refs := CollectReferences(r.Data())
        for _, ref := range refs </span><span class="cov0" title="0">{
                s.AddDependency(r.URN(), ref.URN)
        }</span>

        <span class="cov8" title="1">s.resources[r.URN()] = r</span>
}

func (s *Graph) GetResource(urn string) (*Resource, bool) <span class="cov8" title="1">{
        r, exists := s.resources[urn]
        return r, exists
}</span>

func (s *Graph) GetDependencies(urn string) []string <span class="cov8" title="1">{
        return s.dependencies[urn]
}</span>

func (s *Graph) AddDependency(addedTo string, dependency string) <span class="cov8" title="1">{
        deps := s.dependencies[addedTo]
        for _, dep := range deps </span><span class="cov8" title="1">{
                if dep == dependency </span><span class="cov8" title="1">{
                        return
                }</span>
        }
        <span class="cov8" title="1">s.dependencies[addedTo] = append(s.dependencies[addedTo], dependency)</span>
}

func (s *Graph) AddDependencies(addedTo string, dependencies []string) <span class="cov8" title="1">{
        for _, dep := range dependencies </span><span class="cov8" title="1">{
                s.AddDependency(addedTo, dep)
        }</span>
}

func (s *Graph) Merge(g *Graph) <span class="cov8" title="1">{
        for _, r := range g.resources </span><span class="cov8" title="1">{
                s.AddResource(r)
        }</span>

        <span class="cov8" title="1">for k, v := range g.dependencies </span><span class="cov8" title="1">{
                for _, dep := range v </span><span class="cov8" title="1">{
                        s.AddDependency(k, dep)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package resources

type PropertyRef struct {
        URN      string `json:"urn"`
        Property string `json:"property"`
}

func CollectReferences(v interface{}) []*PropertyRef <span class="cov8" title="1">{
        var refs []*PropertyRef

        switch v := v.(type) </span>{
        case []map[string]interface{}:<span class="cov8" title="1">
                for _, vv := range v </span><span class="cov8" title="1">{
                        refs = append(refs, CollectReferences(vv)...)
                }</span>
        case map[string]interface{}:<span class="cov8" title="1">
                for _, vv := range v </span><span class="cov8" title="1">{
                        refs = append(refs, CollectReferences(vv)...)
                }</span>
        case []interface{}:<span class="cov8" title="1">
                for _, vv := range v </span><span class="cov8" title="1">{
                        refs = append(refs, CollectReferences(vv)...)
                }</span>
        case *PropertyRef:<span class="cov8" title="1">
                refs = append(refs, v)</span>
        case PropertyRef:<span class="cov0" title="0">
                refs = append(refs, &amp;v)</span>
        case ResourceData:<span class="cov8" title="1">
                for _, vv := range v </span><span class="cov8" title="1">{
                        refs = append(refs, CollectReferences(vv)...)
                }</span>
        }

        <span class="cov8" title="1">return refs</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package resources

import (
        "fmt"

        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources/internal"
)

type Resource struct {
        r *internal.Resource
}

type ResourceData map[string]interface{}

func URN(ID string, resourceType string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%s", resourceType, ID)
}</span>

func NewResource(id string, resourceType string, data ResourceData, dependencies []string) *Resource <span class="cov8" title="1">{
        return &amp;Resource{
                r: &amp;internal.Resource{
                        URN:          URN(id, resourceType),
                        ID:           id,
                        Type:         resourceType,
                        Data:         data,
                        Dependencies: dependencies,
                },
        }
}</span>

func (r *Resource) ID() string <span class="cov0" title="0">{
        return r.r.ID
}</span>

func (r *Resource) Type() string <span class="cov0" title="0">{
        return r.r.Type
}</span>

func (r *Resource) Data() ResourceData <span class="cov8" title="1">{
        return r.r.Data
}</span>

func (r *Resource) URN() string <span class="cov8" title="1">{
        return r.r.URN
}</span>

func (r *Resource) Dependencies() []string <span class="cov0" title="0">{
        return r.r.Dependencies
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package state

type ErrIncompatibleVersion struct {
        Version string
}

func (e *ErrIncompatibleVersion) Error() string <span class="cov8" title="1">{
        return "incompatible state version: " + e.Version
}</span>

type ErrURNAlreadyExists struct {
        URN string
}

func (e *ErrURNAlreadyExists) Error() string <span class="cov8" title="1">{
        return "URN already exists: " + e.URN
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package state

import (
        "encoding/json"

        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
)

const LatestVersion = "1.0.0"
const RudderRef = "$__rudderRef"

func ToJSON(state *State) (json.RawMessage, error) <span class="cov8" title="1">{
        // Create a copy of state to avoid modifying the original
        stateCopy := &amp;State{
                Version:   state.Version,
                Resources: make(map[string]*ResourceState),
        }

        if stateCopy.Version == "" </span><span class="cov8" title="1">{
                stateCopy.Version = LatestVersion
        }</span>

        <span class="cov8" title="1">for urn, res := range state.Resources </span><span class="cov8" title="1">{
                stateCopy.Resources[urn] = EncodeResourceState(res)
        }</span>

        <span class="cov8" title="1">return json.Marshal(stateCopy)</span>
}

func EncodeResourceState(state *ResourceState) *ResourceState <span class="cov8" title="1">{
        return &amp;ResourceState{
                ID:           state.ID,
                Type:         state.Type,
                Input:        encodeReferences(state.Input),
                Output:       encodeReferences(state.Output),
                Dependencies: state.Dependencies,
        }
}</span>

func encodeReferences(data map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        result := make(map[string]interface{})

        for k, v := range data </span><span class="cov8" title="1">{
                switch val := v.(type) </span>{
                case resources.PropertyRef:<span class="cov8" title="1">
                        result[k] = map[string]interface{}{
                                RudderRef:  val.URN,
                                "property": val.Property,
                        }</span>

                case []map[string]interface{}:<span class="cov8" title="1">
                        newArray := make([]map[string]interface{}, len(val))
                        for i, item := range val </span><span class="cov8" title="1">{
                                newArray[i] = encodeReferences(item)
                        }</span>
                        <span class="cov8" title="1">result[k] = newArray</span>

                case map[string]interface{}:<span class="cov8" title="1">
                        result[k] = encodeReferences(val)</span>

                case []interface{}:<span class="cov8" title="1">
                        newArray := make([]interface{}, len(val))
                        for i, item := range val </span><span class="cov8" title="1">{

                                if m, ok := item.(resources.PropertyRef); ok </span><span class="cov8" title="1">{
                                        newArray[i] = map[string]interface{}{
                                                RudderRef:  m.URN,
                                                "property": m.Property,
                                        }
                                        continue</span>
                                }
                                <span class="cov8" title="1">if m, ok := item.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                        newArray[i] = encodeReferences(m)
                                }</span> else<span class="cov8" title="1"> {
                                        newArray[i] = item
                                }</span>
                        }
                        <span class="cov8" title="1">result[k] = newArray</span>
                default:<span class="cov8" title="1">
                        result[k] = v</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

func DecodeResourceState(res *ResourceState) *ResourceState <span class="cov8" title="1">{
        return &amp;ResourceState{
                ID:           res.ID,
                Type:         res.Type,
                Input:        decodeReferences(res.Input),
                Output:       decodeReferences(res.Output),
                Dependencies: res.Dependencies,
        }
}</span>

func decodeReferences(data map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{

        result := make(map[string]interface{})

        for k, v := range data </span><span class="cov8" title="1">{
                switch val := v.(type) </span>{
                case map[string]interface{}:<span class="cov8" title="1">
                        if isReference(val) </span><span class="cov8" title="1">{
                                result[k] = resources.PropertyRef{
                                        URN:      val[RudderRef].(string),
                                        Property: val["property"].(string),
                                }
                        }</span> else<span class="cov8" title="1"> {
                                result[k] = decodeReferences(val)
                        }</span>

                case []map[string]interface{}:<span class="cov8" title="1">
                        newMap := make([]map[string]interface{}, len(val))
                        for i, item := range val </span><span class="cov8" title="1">{
                                newMap[i] = decodeReferences(item)
                        }</span>

                        <span class="cov8" title="1">result[k] = newMap</span>

                case []interface{}:<span class="cov8" title="1">
                        newArray := make([]interface{}, len(val))
                        for i, item := range val </span><span class="cov8" title="1">{
                                if m, ok := item.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                        if isReference(m) </span><span class="cov8" title="1">{
                                                newArray[i] = resources.PropertyRef{
                                                        URN:      m[RudderRef].(string),
                                                        Property: m["property"].(string),
                                                }
                                        }</span> else<span class="cov8" title="1"> {
                                                newArray[i] = decodeReferences(m)
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        newArray[i] = item
                                }</span>
                        }
                        <span class="cov8" title="1">result[k] = newArray</span>
                default:<span class="cov8" title="1">
                        result[k] = v</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

func isReference(v interface{}) bool <span class="cov8" title="1">{
        m, ok := v.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">_, hasRef := m[RudderRef]
        _, hasProperty := m["property"]

        return hasRef &amp;&amp; hasProperty</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package state

import (
        "fmt"

        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
)

type State struct {
        Version   string                    `json:"version"`
        Resources map[string]*ResourceState `json:"resources"`
}

func EmptyState() *State <span class="cov8" title="1">{
        return &amp;State{
                Resources: make(map[string]*ResourceState),
        }
}</span>

type ResourceState struct {
        ID           string                 `json:"id"`
        Type         string                 `json:"type"`
        Input        map[string]interface{} `json:"input"`
        Output       map[string]interface{} `json:"output"`
        Dependencies []string               `json:"dependencies"`
}

func (sr *ResourceState) Data() resources.ResourceData <span class="cov8" title="1">{
        data := make(resources.ResourceData)
        for k, v := range sr.Input </span><span class="cov8" title="1">{
                data[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range sr.Output </span><span class="cov8" title="1">{
                data[k] = v
        }</span>
        <span class="cov8" title="1">return data</span>
}

func (s *State) AddResource(r *ResourceState) <span class="cov8" title="1">{
        s.Resources[resources.URN(r.ID, r.Type)] = r
}</span>

func (s *State) RemoveResource(urn string) <span class="cov0" title="0">{
        delete(s.Resources, urn)
}</span>

func (s *State) GetResource(urn string) *ResourceState <span class="cov8" title="1">{
        return s.Resources[urn]
}</span>

func (s *State) String() string <span class="cov0" title="0">{
        json, _ := ToJSON(s)
        return string(json)
}</span>

func Dereference(data resources.ResourceData, state *State) (resources.ResourceData, error) <span class="cov8" title="1">{
        dereferenced, err := dereferenceValue(data, state)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return dereferenced.(resources.ResourceData), nil</span>
}

func dereferenceValue(v interface{}, state *State) (interface{}, error) <span class="cov8" title="1">{
        switch val := v.(type) </span>{
        case resources.PropertyRef:<span class="cov8" title="1">
                resource := state.GetResource(val.URN)
                if resource == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("referred resource '%s' does not exist", val.URN)
                }</span>

                <span class="cov8" title="1">resourceData := resource.Data()
                if resourceData == nil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return dereferenceValue(resourceData[val.Property], state)</span>
        case resources.ResourceData:<span class="cov8" title="1">
                result := make(resources.ResourceData)
                for k, v := range val </span><span class="cov8" title="1">{
                        dereferenced, err := dereferenceValue(v, state)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">result[k] = dereferenced</span>
                }
                <span class="cov8" title="1">return result, nil</span>
        case map[string]interface{}:<span class="cov8" title="1">
                result := make(map[string]interface{})
                for k, v := range val </span><span class="cov8" title="1">{
                        dereferenced, err := dereferenceValue(v, state)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">result[k] = dereferenced</span>
                }
                <span class="cov8" title="1">return result, nil</span>
        case []interface{}:<span class="cov8" title="1">
                result := make([]interface{}, len(val))
                for i, v := range val </span><span class="cov8" title="1">{
                        dereferenced, err := dereferenceValue(v, state)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">result[i] = dereferenced</span>
                }
                <span class="cov8" title="1">return result, nil</span>

        case []map[string]interface{}:<span class="cov8" title="1">
                result := make([]map[string]interface{}, len(val))
                for i, v := range val </span><span class="cov8" title="1">{
                        deferenced, err := dereferenceValue(v, state)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">result[i] = deferenced.(map[string]interface{})</span>
                }
                <span class="cov8" title="1">return result, nil</span>

        default:<span class="cov8" title="1">
                return v, nil</span>
        }
}

// Merge returns a new State, combining the current state with another state.
// If the versions are incompatible it returns an ErrIncompatibleVersion error.
// If there are URNs that exist in both states it returns an ErrURNAlreadyExists error.
func (s *State) Merge(other *State) (*State, error) <span class="cov8" title="1">{
        newState := EmptyState()
        newState.Version = s.Version

        for k, v := range s.Resources </span><span class="cov8" title="1">{
                newState.Resources[k] = v
        }</span>

        <span class="cov8" title="1">if s.Version != other.Version </span><span class="cov8" title="1">{
                return nil, &amp;ErrIncompatibleVersion{Version: other.Version}
        }</span>

        <span class="cov8" title="1">for k, v := range other.Resources </span><span class="cov8" title="1">{
                if _, exists := s.Resources[k]; exists </span><span class="cov8" title="1">{
                        return nil, &amp;ErrURNAlreadyExists{URN: k}
                }</span>
                <span class="cov8" title="1">newState.Resources[k] = v</span>
        }

        <span class="cov8" title="1">return newState, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package syncer

import (
        "context"
        "fmt"

        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/differ"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/planner"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/state"
        "github.com/rudderlabs/rudder-iac/cli/internal/ui"
)

type ProjectSyncer struct {
        provider SyncProvider
}

type SyncProvider interface {
        LoadState(ctx context.Context) (*state.State, error)
        PutResourceState(ctx context.Context, URN string, state *state.ResourceState) error
        DeleteResourceState(ctx context.Context, state *state.ResourceState) error
        Create(ctx context.Context, ID string, resourceType string, data resources.ResourceData) (*resources.ResourceData, error)
        Update(ctx context.Context, ID string, resourceType string, data resources.ResourceData, state resources.ResourceData) (*resources.ResourceData, error)
        Delete(ctx context.Context, ID string, resourceType string, state resources.ResourceData) error
}

func New(p SyncProvider) (*ProjectSyncer, error) <span class="cov8" title="1">{
        if p == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider is required")
        }</span>

        <span class="cov8" title="1">return &amp;ProjectSyncer{
                provider: p,
        }, nil</span>
}

type SyncOptions struct {
        // DryRun is a flag to indicate if the syncer should only plan the changes, without applying them
        DryRun bool
        // Confirm is a flag to indicate if the syncer should ask for confirmation before applying the changes
        Confirm bool
}

func (s *ProjectSyncer) Sync(ctx context.Context, target *resources.Graph, options SyncOptions) error <span class="cov8" title="1">{
        errs := s.apply(ctx, target, options, false)
        if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return errs[0]
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *ProjectSyncer) Destroy(ctx context.Context, options SyncOptions) []error <span class="cov0" title="0">{
        return s.apply(ctx, resources.NewGraph(), options, true)
}</span>

func (s *ProjectSyncer) apply(ctx context.Context, target *resources.Graph, options SyncOptions, continueOnFail bool) []error <span class="cov8" title="1">{
        state, err := s.provider.LoadState(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return []error{err}
        }</span>

        <span class="cov8" title="1">source := stateToGraph(state)

        p := planner.New()
        plan := p.Plan(source, target)

        differ.PrintDiff(plan.Diff)

        if options.DryRun </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if len(plan.Operations) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No changes to apply")
                return nil
        }</span>

        <span class="cov8" title="1">if options.Confirm </span><span class="cov0" title="0">{
                confirm, err := ui.Confirm("Do you want to apply these changes?")
                if err != nil </span><span class="cov0" title="0">{
                        return []error{err}
                }</span>

                <span class="cov0" title="0">if !confirm </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return s.executePlan(ctx, state, plan, continueOnFail)</span>
}

func stateToGraph(state *state.State) *resources.Graph <span class="cov8" title="1">{
        graph := resources.NewGraph()

        for _, stateResource := range state.Resources </span><span class="cov8" title="1">{
                resource := resources.NewResource(stateResource.ID, stateResource.Type, stateResource.Input, stateResource.Dependencies)
                graph.AddResource(resource)
                // add any explicit dependencies, not mentioned through references
                graph.AddDependencies(resource.URN(), stateResource.Dependencies)
        }</span>

        <span class="cov8" title="1">return graph</span>
}

type OperationError struct {
        Operation *planner.Operation
        Err       error
}

func (e *OperationError) Error() string <span class="cov0" title="0">{
        return e.Err.Error()
}</span>

func (e *OperationError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

func (s *ProjectSyncer) executePlan(ctx context.Context, state *state.State, plan *planner.Plan, continueOnFail bool) []error <span class="cov8" title="1">{
        var (
                errors       []error
                currentState = state
        )

        for _, o := range plan.Operations </span><span class="cov8" title="1">{
                operationString := o.String()
                spinner := ui.NewSpinner(operationString)
                spinner.Start()

                outputState, providerErr := s.providerOperation(ctx, o, currentState)
                spinner.Stop()
                if providerErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("%s %s\n", ui.Color("x", ui.Red), operationString)
                        errors = append(errors, &amp;OperationError{Operation: o, Err: providerErr})
                        if !continueOnFail </span><span class="cov0" title="0">{
                                return errors
                        }</span>
                }

                <span class="cov8" title="1">if outputState == nil </span><span class="cov0" title="0">{
                        outputState = currentState
                }</span>

                <span class="cov8" title="1">if providerErr == nil </span><span class="cov8" title="1">{
                        fmt.Printf("%s %s\n", ui.Color("✔", ui.Green), operationString)
                }</span>

                <span class="cov8" title="1">currentState = outputState</span>
        }

        <span class="cov8" title="1">return errors</span>
}

func (s *ProjectSyncer) createOperation(ctx context.Context, r *resources.Resource, st *state.State) (*state.State, error) <span class="cov8" title="1">{
        input := r.Data()
        dereferenced, err := state.Dereference(input, st)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output, err := s.provider.Create(ctx, r.ID(), r.Type(), dereferenced)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">sr := &amp;state.ResourceState{
                ID:           r.ID(),
                Type:         r.Type(),
                Input:        input,
                Output:       *output,
                Dependencies: r.Dependencies(),
        }

        if err := s.provider.PutResourceState(ctx, r.URN(), sr); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update resource state: %w", err)
        }</span>

        <span class="cov8" title="1">st.AddResource(sr)

        return st, nil</span>
}

func (s *ProjectSyncer) updateOperation(ctx context.Context, r *resources.Resource, st *state.State) (*state.State, error) <span class="cov0" title="0">{
        input := r.Data()
        dereferenced, err := state.Dereference(input, st)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sr := st.GetResource(r.URN())
        if sr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("resource not found in state: %s", r.URN())
        }</span>

        <span class="cov0" title="0">output, err := s.provider.Update(ctx, r.ID(), r.Type(), dereferenced, sr.Data())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sr = &amp;state.ResourceState{
                ID:           sr.ID,
                Type:         sr.Type,
                Input:        input,
                Output:       *output,
                Dependencies: r.Dependencies(),
        }

        if err := s.provider.PutResourceState(ctx, r.URN(), sr); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update resource state: %w", err)
        }</span>

        <span class="cov0" title="0">st.AddResource(sr)

        return st, nil</span>
}

func (s *ProjectSyncer) deleteOperation(ctx context.Context, r *resources.Resource, st *state.State) (*state.State, error) <span class="cov8" title="1">{
        sr := st.GetResource(r.URN())
        if sr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("resource not found in state: %s", r.URN())
        }</span>

        <span class="cov8" title="1">if err := s.provider.DeleteResourceState(ctx, sr); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to delete resource state: %w", err)
        }</span>

        <span class="cov8" title="1">err := s.provider.Delete(ctx, r.ID(), r.Type(), sr.Data())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">st.RemoveResource(r.URN())

        return st, nil</span>
}

func (s *ProjectSyncer) providerOperation(ctx context.Context, o *planner.Operation, st *state.State) (*state.State, error) <span class="cov8" title="1">{
        r := o.Resource

        switch o.Type </span>{
        case planner.Create:<span class="cov8" title="1">
                return s.createOperation(ctx, r, st)</span>
        case planner.Update:<span class="cov0" title="0">
                return s.updateOperation(ctx, r, st)</span>
        case planner.Delete:<span class="cov8" title="1">
                return s.deleteOperation(ctx, r, st)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown operation type with code: %d", o.Type)</span>
        }
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package telemetry

import (
        "fmt"

        "github.com/rudderlabs/analytics-go/v4"
        "github.com/rudderlabs/rudder-iac/cli/pkg/logger"
)

// CLI deals with only the internal logger interface
// so we need to write an adapter to make sure analytics client
// can log using our logger
var _ analytics.Logger = NewTelemetryLogger()

type TelemetryLogger struct {
        log *logger.Logger
}

func (l *TelemetryLogger) Logf(format string, args ...interface{}) <span class="cov0" title="0">{
        l.log.Info(fmt.Sprintf(format, args...))
}</span>

func (l *TelemetryLogger) Errorf(format string, args ...interface{}) <span class="cov0" title="0">{
        l.log.Error(fmt.Sprintf(format, args...))
}</span>

func NewTelemetryLogger() *TelemetryLogger <span class="cov0" title="0">{
        return &amp;TelemetryLogger{
                log: logger.New("telemetry"),
        }
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package telemetry

import (
        "fmt"
        "sync"

        "github.com/google/uuid"
        "github.com/rudderlabs/analytics-go/v4"
        "github.com/rudderlabs/rudder-iac/cli/internal/config"
)

var (
        once sync.Once
        v    string
)

func Initialise(version string) <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{

                if config.GetConfig().Telemetry.Disabled </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">v = version

                if config.GetConfig().Telemetry.AnonymousID == "" </span><span class="cov0" title="0">{
                        anonymousID := uuid.New().String()
                        config.SetTelemetryAnonymousID(anonymousID)
                }</span>
        })
}

func DisableTelemetry() <span class="cov0" title="0">{
        config.SetTelemetryDisabled(true)
}</span>

func EnableTelemetry() <span class="cov0" title="0">{
        config.SetTelemetryDisabled(false)
}</span>

func track(event string, properties analytics.Properties) error <span class="cov0" title="0">{
        if config.GetConfig().Telemetry.Disabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var (
                anonymousID  = config.GetConfig().Telemetry.AnonymousID
                writeKey     = config.GetConfig().Telemetry.WriteKey
                dataplaneURL = config.GetConfig().Telemetry.DataplaneURL
        )

        client, err := analytics.NewWithConfig(writeKey, analytics.Config{
                DataPlaneUrl: dataplaneURL,
                Logger:       NewTelemetryLogger(),
        })

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create analytics client: %w", err)
        }</span>

        <span class="cov0" title="0">defer client.Close()

        return client.Enqueue(analytics.Track{
                Event:       event,
                Properties:  properties,
                AnonymousId: anonymousID,
                Context: &amp;analytics.Context{
                        App: analytics.AppInfo{
                                Name:    "rudder-cli",
                                Version: v,
                        },
                },
        })</span>
}

func TrackEvent(event string, props map[string]interface{}) error <span class="cov0" title="0">{
        properties := analytics.NewProperties()

        for k, v := range props </span><span class="cov0" title="0">{
                properties.Set(k, v)
        }</span>

        <span class="cov0" title="0">return track(event, properties)</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package testutils

import (
        "context"

        "github.com/rudderlabs/rudder-iac/cli/internal/project/specs"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/state"
)

// MockProvider is a mock implementation of the project.Provider interface for testing.
type MockProvider struct {
        SupportedKinds         []string
        SupportedTypes         []string
        ValidateErr            error
        LoadSpecErr            error
        GetResourceGraphVal    *resources.Graph
        GetResourceGraphErr    error
        LoadStateVal           *state.State
        LoadStateErr           error
        PutResourceStateErr    error
        DeleteResourceStateErr error
        CreateVal              *resources.ResourceData
        CreateErr              error
        UpdateVal              *resources.ResourceData
        UpdateErr              error
        DeleteErr              error

        // Tracking calls
        ValidateCalledCount              int
        LoadSpecCalledWithArgs           []LoadSpecArgs
        GetResourceGraphCalledCount      int
        LoadStateCalledCount             int
        PutResourceStateCalledWithArg    PutResourceStateArgs
        DeleteResourceStateCalledWithArg *state.ResourceState
        CreateCalledWithArg              CreateArgs
        UpdateCalledWithArg              UpdateArgs
        DeleteCalledWithArg              DeleteArgs
}

// LoadSpecArgs stores arguments for LoadSpec calls
type LoadSpecArgs struct {
        Path string
        Spec *specs.Spec
}

// PutResourceStateArgs stores arguments for PutResourceState calls
type PutResourceStateArgs struct {
        URN   string
        State *state.ResourceState
}

// CreateArgs stores arguments for Create calls
type CreateArgs struct {
        ID           string
        ResourceType string
        Data         resources.ResourceData
}

// UpdateArgs stores arguments for Update calls
type UpdateArgs struct {
        ID           string
        ResourceType string
        Data         resources.ResourceData
        State        resources.ResourceData
}

// DeleteArgs stores arguments for Delete calls
type DeleteArgs struct {
        ID           string
        ResourceType string
        State        resources.ResourceData
}

// NewMockProvider creates a new MockProvider with initialized tracking fields.
func NewMockProvider() *MockProvider <span class="cov0" title="0">{
        return &amp;MockProvider{
                LoadSpecCalledWithArgs: make([]LoadSpecArgs, 0),
        }
}</span>

func (m *MockProvider) GetSupportedKinds() []string <span class="cov0" title="0">{
        return m.SupportedKinds
}</span>

func (m *MockProvider) GetSupportedTypes() []string <span class="cov0" title="0">{
        return m.SupportedTypes
}</span>

func (m *MockProvider) Validate() error <span class="cov0" title="0">{
        m.ValidateCalledCount++
        return m.ValidateErr
}</span>

func (m *MockProvider) LoadSpec(path string, s *specs.Spec) error <span class="cov0" title="0">{
        m.LoadSpecCalledWithArgs = append(m.LoadSpecCalledWithArgs, LoadSpecArgs{Path: path, Spec: s})
        return m.LoadSpecErr
}</span>

func (m *MockProvider) GetResourceGraph() (*resources.Graph, error) <span class="cov0" title="0">{
        m.GetResourceGraphCalledCount++
        return m.GetResourceGraphVal, m.GetResourceGraphErr
}</span>

func (m *MockProvider) LoadState(ctx context.Context) (*state.State, error) <span class="cov0" title="0">{
        m.LoadStateCalledCount++
        return m.LoadStateVal, m.LoadStateErr
}</span>

func (m *MockProvider) PutResourceState(ctx context.Context, URN string, s *state.ResourceState) error <span class="cov0" title="0">{
        m.PutResourceStateCalledWithArg = PutResourceStateArgs{URN: URN, State: s}
        return m.PutResourceStateErr
}</span>

func (m *MockProvider) DeleteResourceState(ctx context.Context, s *state.ResourceState) error <span class="cov0" title="0">{
        m.DeleteResourceStateCalledWithArg = s
        return m.DeleteResourceStateErr
}</span>

func (m *MockProvider) Create(ctx context.Context, ID string, resourceType string, data resources.ResourceData) (*resources.ResourceData, error) <span class="cov0" title="0">{
        m.CreateCalledWithArg = CreateArgs{ID: ID, ResourceType: resourceType, Data: data}
        return m.CreateVal, m.CreateErr
}</span>

func (m *MockProvider) Update(ctx context.Context, ID string, resourceType string, data resources.ResourceData, s resources.ResourceData) (*resources.ResourceData, error) <span class="cov0" title="0">{
        m.UpdateCalledWithArg = UpdateArgs{ID: ID, ResourceType: resourceType, Data: data, State: s}
        return m.UpdateVal, m.UpdateErr
}</span>

func (m *MockProvider) Delete(ctx context.Context, ID string, resourceType string, s resources.ResourceData) error <span class="cov0" title="0">{
        m.DeleteCalledWithArg = DeleteArgs{ID: ID, ResourceType: resourceType, State: s}
        return m.DeleteErr
}</span>

// ResetCallCounters resets all call counters and argument trackers.
func (m *MockProvider) ResetCallCounters() <span class="cov0" title="0">{
        m.ValidateCalledCount = 0
        m.LoadSpecCalledWithArgs = make([]LoadSpecArgs, 0)
        m.GetResourceGraphCalledCount = 0
        m.LoadStateCalledCount = 0
        m.PutResourceStateCalledWithArg = PutResourceStateArgs{}
        m.DeleteResourceStateCalledWithArg = nil
        m.CreateCalledWithArg = CreateArgs{}
        m.UpdateCalledWithArg = UpdateArgs{}
        m.DeleteCalledWithArg = DeleteArgs{}
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package testutils

import (
        "context"
        "fmt"

        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/state"
)

const (
        EventResourceType        = "event"
        PropertyResourceType     = "property"
        TrackingPlanResourceType = "tracking-plan"
)

func NewMockEvent(ID string, data resources.ResourceData) *resources.Resource <span class="cov0" title="0">{
        return resources.NewResource(ID, EventResourceType, data, make([]string, 0))
}</span>

func NewMockProperty(ID string, data resources.ResourceData) *resources.Resource <span class="cov0" title="0">{
        return resources.NewResource(ID, PropertyResourceType, data, make([]string, 0))
}</span>

func NewMockTrackingPlan(ID string, data resources.ResourceData) *resources.Resource <span class="cov0" title="0">{
        return resources.NewResource(ID, TrackingPlanResourceType, data, make([]string, 0))
}</span>

type OperationLogEntry struct {
        Operation string
        Args      []interface{}
}

type DataCatalogProvider struct {
        InitialState *state.State
        OperationLog []OperationLogEntry
}

func (p *DataCatalogProvider) LoadState(_ context.Context) (*state.State, error) <span class="cov0" title="0">{
        return p.InitialState, nil
}</span>

func (p *DataCatalogProvider) PutResourceState(_ context.Context, ID string, state *state.ResourceState) error <span class="cov0" title="0">{
        p.logOperation("PutResourceState", ID, state)
        return nil
}</span>

func (p *DataCatalogProvider) DeleteResourceState(_ context.Context, state *state.ResourceState) error <span class="cov0" title="0">{
        p.logOperation("DeleteResourceState", state)
        return nil
}</span>

func (p *DataCatalogProvider) Create(_ context.Context, ID string, resourceType string, data resources.ResourceData) (*resources.ResourceData, error) <span class="cov0" title="0">{
        payload := make(resources.ResourceData)
        payload["id"] = fmt.Sprintf("generated-%s-%s", resourceType, ID)

        p.logOperation("Create", ID, resourceType, data)

        return &amp;payload, nil
}</span>

func (p *DataCatalogProvider) Update(_ context.Context, ID string, resourceType string, data resources.ResourceData, state resources.ResourceData) (*resources.ResourceData, error) <span class="cov0" title="0">{
        payload := make(resources.ResourceData)
        payload["id"] = fmt.Sprintf("generated-%s-%s", resourceType, ID)

        p.logOperation("Update", ID, resourceType, data, state)

        return &amp;payload, nil
}</span>

func (p *DataCatalogProvider) Delete(_ context.Context, ID string, resourceType string, state resources.ResourceData) error <span class="cov0" title="0">{
        p.logOperation("Delete", ID, resourceType, state)
        return nil
}</span>

func (p *DataCatalogProvider) logOperation(operation string, args ...interface{}) <span class="cov0" title="0">{
        p.OperationLog = append(p.OperationLog, OperationLogEntry{
                Operation: operation,
                Args:      args,
        })
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package ui

import (
        "fmt"
        "strings"

        "github.com/AlecAivazis/survey/v2"
)

// AskSecret asks the user a question and reads the response as a secret.
// The response is trimmed of leading and trailing whitespace.
func AskSecret(question string) (string, error) <span class="cov0" title="0">{
        response := ""
        prompt := &amp;survey.Password{
                Message: question,
        }

        if err := survey.AskOne(prompt, &amp;response); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error reading response: %w", err)
        }</span>

        <span class="cov0" title="0">response = strings.TrimSpace(response)

        return response, nil</span>
}

func Confirm(question string) (bool, error) <span class="cov0" title="0">{
        response := false
        prompt := &amp;survey.Confirm{
                Message: question,
        }

        if err := survey.AskOne(prompt, &amp;response); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("error reading response: %w", err)
        }</span>

        <span class="cov0" title="0">return response, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package ui

import (
        "fmt"

        "github.com/charmbracelet/lipgloss"
)

func ShowError(err error) <span class="cov0" title="0">{
        style := lipgloss.NewStyle().
                Foreground(lipgloss.Color(Red)).
                Bold(true).
                Render

        fmt.Println(style("Error: ") + err.Error())
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package ui

import (
        "time"

        "github.com/briandowns/spinner"
)

func NewSpinner(message string) *spinner.Spinner <span class="cov0" title="0">{
        return spinner.New(spinner.CharSets[14], 100*time.Millisecond, spinner.WithSuffix(" "+message))
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package ui

import "github.com/charmbracelet/lipgloss"

func Bold(s string) string <span class="cov0" title="0">{
        return lipgloss.NewStyle().Bold(true).Render(s)
}</span>

func Color(s string, color string) string <span class="cov0" title="0">{
        return lipgloss.NewStyle().Foreground(lipgloss.Color(color)).Render(s)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package localcatalog

import (
        "fmt"

        "github.com/rudderlabs/rudder-iac/cli/internal/project/specs"
        "github.com/rudderlabs/rudder-iac/cli/pkg/logger"
)

var (
        log = logger.New("localcatalog")
)

// entity group is logical grouping of entities defined
// as metadata-&gt;name in respective yaml file
type EntityGroup string

// Create a reverse lookup based on the groupName and identifier per entity
type DataCatalog struct {
        Properties    map[EntityGroup][]Property    `json:"properties"`
        Events        map[EntityGroup][]Event       `json:"events"`
        TrackingPlans map[EntityGroup]*TrackingPlan `json:"trackingPlans"` // Only one tracking plan per entity group
        CustomTypes   map[EntityGroup][]CustomType  `json:"customTypes"`   // Custom types grouped by entity group
}

func (dc *DataCatalog) Property(groupName string, id string) *Property <span class="cov0" title="0">{
        if props, ok := dc.Properties[EntityGroup(groupName)]; ok </span><span class="cov0" title="0">{
                for _, prop := range props </span><span class="cov0" title="0">{
                        if prop.LocalID == id </span><span class="cov0" title="0">{
                                return &amp;prop
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (dc *DataCatalog) Event(groupName string, id string) *Event <span class="cov0" title="0">{
        if events, ok := dc.Events[EntityGroup(groupName)]; ok </span><span class="cov0" title="0">{
                for _, event := range events </span><span class="cov0" title="0">{
                        if event.LocalID == id </span><span class="cov0" title="0">{
                                return &amp;event
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// CustomType returns a custom type by group name and ID
func (dc *DataCatalog) CustomType(groupName string, id string) *CustomType <span class="cov0" title="0">{
        if types, ok := dc.CustomTypes[EntityGroup(groupName)]; ok </span><span class="cov0" title="0">{
                for _, customType := range types </span><span class="cov0" title="0">{
                        if customType.LocalID == id </span><span class="cov0" title="0">{
                                return &amp;customType
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (dc *DataCatalog) TPEventRule(tpGroup, ruleID string) *TPRule <span class="cov0" title="0">{
        tp, ok := dc.TrackingPlans[EntityGroup(tpGroup)]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, rule := range tp.Rules </span><span class="cov0" title="0">{
                if rule.LocalID == ruleID &amp;&amp; rule.Type == "event_rule" </span><span class="cov0" title="0">{
                        return rule
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (dc *DataCatalog) TPEventRules(tpGroup string) ([]*TPRule, bool) <span class="cov0" title="0">{
        tp, ok := dc.TrackingPlans[EntityGroup(tpGroup)]
        if !ok </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">var toReturn []*TPRule
        for _, rule := range tp.Rules </span><span class="cov0" title="0">{
                if rule.Type != "event_rule" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">toReturn = append(toReturn, rule)</span>
        }

        <span class="cov0" title="0">return toReturn, true</span>
}

func New() *DataCatalog <span class="cov0" title="0">{
        return &amp;DataCatalog{
                Properties:    map[EntityGroup][]Property{},
                Events:        map[EntityGroup][]Event{},
                TrackingPlans: map[EntityGroup]*TrackingPlan{},
                CustomTypes:   map[EntityGroup][]CustomType{},
        }
}</span>

func (dc *DataCatalog) LoadSpec(path string, s *specs.Spec) error <span class="cov0" title="0">{
        if err := extractEntities(s, dc); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("extracting data catalog entity from file: %s : %w", path, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// extractEntities parses the entity from file bytes
// and updates the datacatalog struct with it.
func extractEntities(s *specs.Spec, dc *DataCatalog) error <span class="cov8" title="1">{
        // TODO: properly handle metadata - ensuring schema and types
        name := s.Metadata["name"].(string)
        switch s.Kind </span>{
        case "properties":<span class="cov8" title="1">
                properties, err := ExtractProperties(s)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("extracting properties: %w", err)
                }</span>
                <span class="cov8" title="1">dc.Properties[EntityGroup(name)] = properties</span>

        case "events":<span class="cov8" title="1">
                events, err := ExtractEvents(s)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("extracting property entity: %w", err)
                }</span>
                <span class="cov8" title="1">dc.Events[EntityGroup(name)] = events</span>

        case "tp":<span class="cov8" title="1">
                tp, err := ExtractTrackingPlan(s)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("extracting tracking plan: %w", err)
                }</span>

                <span class="cov8" title="1">dc.TrackingPlans[EntityGroup(name)] = &amp;tp</span>

        case "custom-types":<span class="cov8" title="1">
                customTypes, err := ExtractCustomTypes(s)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("extracting custom types: %w", err)
                }</span>
                <span class="cov8" title="1">dc.CustomTypes[EntityGroup(name)] = customTypes</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown kind: %s", s.Kind)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package localcatalog

import (
        "encoding/json"
        "fmt"

        "github.com/rudderlabs/rudder-iac/cli/internal/project/specs"
)

type Property struct {
        LocalID     string                 `json:"id"`
        Name        string                 `json:"name"`
        Description string                 `json:"description"`
        Type        string                 `json:"type"`
        Config      map[string]interface{} `json:"propConfig"`
}

type PropertySpec struct {
        Properties []Property `json:"properties"`
}

// This method is used to extract the entity from the byte representation of it
func ExtractProperties(s *specs.Spec) ([]Property, error) <span class="cov8" title="1">{
        spec := PropertySpec{}

        jsonByt, err := json.Marshal(s.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshalling the spec: %w", err)
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(jsonByt, &amp;spec); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("extracting the property spec: %w", err)
        }</span>

        <span class="cov8" title="1">return spec.Properties, nil</span>
}

type Event struct {
        LocalID     string   `json:"id"`
        Name        string   `json:"name"`
        Type        string   `json:"event_type"`
        Description string   `json:"description"`
        Categories  []string `json:"categories"`
}

type EventSpec struct {
        Events []Event `json:"events"`
}

// ExtractEvents simply parses the whole file defined as resource definition
// and returns the events from it.
func ExtractEvents(s *specs.Spec) ([]Event, error) <span class="cov8" title="1">{
        spec := EventSpec{}

        jsonByt, err := json.Marshal(s.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshalling the spec: %w", err)
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(jsonByt, &amp;spec); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("extracting events spec: %w", err)
        }</span>

        <span class="cov8" title="1">return spec.Events, nil</span>
}

// CustomType represents a user-defined custom type
type CustomType struct {
        LocalID     string                 `json:"id"`
        Name        string                 `json:"name"`
        Description string                 `json:"description"`
        Type        string                 `json:"type"`
        Config      map[string]interface{} `json:"config"`
        Properties  []CustomTypeProperty   `json:"properties,omitempty"`
}

// CustomTypeProperty represents a property reference within a custom type
type CustomTypeProperty struct {
        Ref      string `json:"$ref"`
        Required bool   `json:"required"`
}

// CustomTypeSpec represents the spec section of a custom-types resource
type CustomTypeSpec struct {
        Types []CustomType `json:"types"`
}

// ExtractCustomTypes parses a resource definition and extracts custom types
func ExtractCustomTypes(s *specs.Spec) ([]CustomType, error) <span class="cov8" title="1">{
        spec := CustomTypeSpec{}

        jsonByt, err := json.Marshal(s.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshalling the spec: %w", err)
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(jsonByt, &amp;spec); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("extracting custom types spec: %w", err)
        }</span>

        // Ensure config is initialized as an empty map when nil
        <span class="cov8" title="1">for i := range spec.Types </span><span class="cov8" title="1">{
                if spec.Types[i].Config == nil </span><span class="cov8" title="1">{
                        spec.Types[i].Config = make(map[string]interface{})
                }</span>
        }

        <span class="cov8" title="1">return spec.Types, nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package localcatalog

import (
        "encoding/json"
        "fmt"
        "regexp"

        "github.com/rudderlabs/rudder-iac/cli/internal/project/specs"
)

var (
        PropRegex       = regexp.MustCompile(`^#\/properties\/(.*)\/(.*)$`)
        EventRegex      = regexp.MustCompile(`^#\/events\/(.*)\/(.*)$`)
        IncludeRegex    = regexp.MustCompile(`^#\/tp\/(.*)\/event_rule\/(.*)$`)
        CustomTypeRegex = regexp.MustCompile(`^#\/custom-types\/(.*)\/(.*)$`)
)

type CatalogResourceFetcher interface {
        Event(group, id string) *Event
        Property(group, id string) *Property
        TPEventRule(group, id string) *TPRule
        TPEventRules(group string) ([]*TPRule, bool)
}

type TrackingPlan struct {
        Name        string    `json:"display_name"`
        LocalID     string    `json:"id"`
        Description string    `json:"description"`
        Rules       []*TPRule `json:"rules"`
        // Event and Props underneath event on the tracking plan
        // This is automatically generated by the code when expanding refs
        EventProps []*TPEvent `json:"event_props"`
}

type TPEvent struct {
        Name            string
        LocalID         string
        Description     string
        Type            string
        AllowUnplanned  bool
        IdentitySection string
        Properties      []*TPEventProperty
}

func (e *TPEvent) PropertyByLocalID(localID string) *TPEventProperty <span class="cov0" title="0">{
        for _, prop := range e.Properties </span><span class="cov0" title="0">{
                if prop.LocalID == localID </span><span class="cov0" title="0">{
                        return prop
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type TPEventProperty struct {
        Name        string                 `json:"name"`
        LocalID     string                 `json:"id"`
        Description string                 `json:"description"`
        Type        string                 `json:"type"`
        Config      map[string]interface{} `json:"config"`
        Required    bool                   `json:"required"`
}

type TPRule struct {
        Type       string            `json:"type"`
        LocalID    string            `json:"id"`
        Event      *TPRuleEvent      `json:"event"`
        Properties []*TPRuleProperty `json:"properties"`
        Includes   *TPRuleIncludes   `json:"includes"`
}

type TPRuleEvent struct {
        Ref             string `json:"$ref"`
        AllowUnplanned  bool   `json:"allow_unplanned"`
        IdentitySection string `json:"identity_section"`
}

type TPRuleProperty struct {
        Ref      string `json:"$ref"`
        Required bool   `json:"required"`
}

type TPRuleIncludes struct {
        Ref string `json:"$ref"`
}

// ExpandRefs simply expands the references being held
// when reading the tracking plan with the actual events and properties
func (tp *TrackingPlan) ExpandRefs(dc *DataCatalog) error <span class="cov0" title="0">{
        log.Debug("expanding refs for the tracking plan", "id", tp.LocalID)

        expandedEvents := make([]*TPEvent, 0)
        for _, rule := range tp.Rules </span><span class="cov0" title="0">{

                switch </span>{
                case rule.Event != nil:<span class="cov0" title="0">
                        tpEvent, err := expandEventRefs(rule, dc)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("expanding event refs on the rule: %s in tracking plan: %s, err:%w",
                                        rule.LocalID,
                                        tp.LocalID,
                                        err)
                        }</span>
                        <span class="cov0" title="0">expandedEvents = append(expandedEvents, tpEvent)</span>

                case rule.Includes != nil:<span class="cov0" title="0">
                        tpEvents, err := expandIncludeRefs(rule, dc)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("expanding include refs on the rule: %s in tracking plan: %s, err:%w",
                                        rule.LocalID,
                                        tp.LocalID,
                                        err)
                        }</span>
                        <span class="cov0" title="0">expandedEvents = append(expandedEvents, tpEvents...)</span>

                default:<span class="cov0" title="0">
                        return fmt.Errorf("both the event and includes section in the rule:%s for tp: %s are nil", rule.LocalID, tp.LocalID)</span>
                }

        }
        <span class="cov0" title="0">tp.EventProps = expandedEvents
        return nil</span>
}

// expandIncludeRefs expands the include references in the tracking plan rule definition
// TODO: Make this function recursive to allow for multiple levels of include
func expandIncludeRefs(rule *TPRule, fetcher CatalogResourceFetcher) ([]*TPEvent, error) <span class="cov0" title="0">{
        log.Debug("expanding include refs within the rule", "ruleID", rule.LocalID)

        if rule.Includes == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty rule includes")
        }</span>

        <span class="cov0" title="0">matches := IncludeRegex.FindStringSubmatch(rule.Includes.Ref)
        if len(matches) != 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("includes ref: %s invalid as failed regex match", rule.Includes.Ref)
        }</span>

        <span class="cov0" title="0">tpGroup, ruleID := matches[1], matches[2]
        rules := make([]*TPRule, 0)

        if ruleID == "*" </span><span class="cov0" title="0">{
                eventRules, _ := fetcher.TPEventRules(tpGroup)
                rules = append(rules, eventRules...) // fetch all the tp rules in the group
        }</span> else<span class="cov0" title="0"> {
                rules = append(rules, fetcher.TPEventRule(tpGroup, ruleID)) // fetch the specific rule with the tpGroup
        }</span>

        <span class="cov0" title="0">toReturn := make([]*TPEvent, 0)
        // Assume rules are now actual rules and not indirections
        for _, rule := range rules </span><span class="cov0" title="0">{

                if rule.Event == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // This rule should have event ref only
                // which we can expand now
                <span class="cov0" title="0">event, err := expandEventRefs(rule, fetcher)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expanding event ref of the expanded include rule: %s failed, err: %w", rule.LocalID, err)
                }</span>

                <span class="cov0" title="0">toReturn = append(toReturn, event)</span>
        }

        <span class="cov0" title="0">return toReturn, nil</span>
}

// expandEventRefs expands the direct event references in the tracking plan rule definition
func expandEventRefs(rule *TPRule, fetcher CatalogResourceFetcher) (*TPEvent, error) <span class="cov0" title="0">{
        log.Debug("expanding event refs within the rule", "ruleID", rule.LocalID)

        if rule.Event == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty rule event")
        }</span>

        <span class="cov0" title="0">matches := EventRegex.FindStringSubmatch(rule.Event.Ref)
        if len(matches) != 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("event ref: %s invalid as failed regex match", rule.Event.Ref)
        }</span>

        <span class="cov0" title="0">eventGroup, eventID := matches[1], matches[2]
        event := fetcher.Event(eventGroup, eventID)
        if event == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("looking up event: %s in group: %s failed", eventID, eventGroup)
        }</span>

        <span class="cov0" title="0">toReturn := TPEvent{
                Name:            event.Name,
                LocalID:         event.LocalID,
                Description:     event.Description,
                Type:            event.Type,
                AllowUnplanned:  rule.Event.AllowUnplanned,
                IdentitySection: rule.Event.IdentitySection,
                Properties:      make([]*TPEventProperty, 0),
        }

        // Load the properties from the data catalog
        // into corresponding event on the tracking plan
        for _, prop := range rule.Properties </span><span class="cov0" title="0">{
                matches = PropRegex.FindStringSubmatch(prop.Ref)
                if len(matches) != 3 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("property ref: %s invalid as failed regex match", prop.Ref)
                }</span>

                <span class="cov0" title="0">propertyGroup, propertyID := matches[1], matches[2]
                property := fetcher.Property(propertyGroup, propertyID)
                if property == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("looking up property: %s in group: %s failed", propertyID, propertyGroup)
                }</span>

                <span class="cov0" title="0">toReturn.Properties = append(toReturn.Properties, &amp;TPEventProperty{
                        Name:        property.Name,
                        LocalID:     property.LocalID,
                        Description: property.Description,
                        Type:        property.Type,
                        Required:    prop.Required,
                        Config:      shallowCopy(property.Config),
                })</span>
        }

        <span class="cov0" title="0">return &amp;toReturn, nil</span>
}

func shallowCopy(input map[string]any) map[string]any <span class="cov0" title="0">{
        output := make(map[string]any, len(input))

        for k, v := range input </span><span class="cov0" title="0">{
                output[k] = v
        }</span>

        <span class="cov0" title="0">return output</span>
}

func ExtractTrackingPlan(s *specs.Spec) (TrackingPlan, error) <span class="cov8" title="1">{
        log.Debug("extracting tracking plan from resource definition", "metadata.name", s.Metadata["name"])

        // The spec is the tracking plan in its enterity
        tp := TrackingPlan{}

        byt, err := json.Marshal(s.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return TrackingPlan{}, fmt.Errorf("marshalling the spec")
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(byt, &amp;tp); err != nil </span><span class="cov0" title="0">{
                return TrackingPlan{}, fmt.Errorf("unmarshalling the spec into tracking plan")
        }</span>

        <span class="cov8" title="1">return tp, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package logger

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
)

// Writing a wrapper over the slog
// Levels as caller shouldn't know about the library used
// for implementation.
type Level int

type Attr struct {
        Key   string
        Value string
}

var logFile *os.File
var levelVar = new(slog.LevelVar)

func init() <span class="cov0" title="0">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error getting home directory: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">logPath := filepath.Join(homeDir, ".rudder", "cli.log")
        if err := os.MkdirAll(filepath.Dir(logPath), 0755); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error creating log directory: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">lf, err := os.OpenFile(logPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error opening log file: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">logFile = lf</span>
}

type Logger struct {
        *slog.Logger
}

func New(pkgName string, attrs ...Attr) *Logger <span class="cov0" title="0">{
        h := slog.NewTextHandler(logFile, &amp;slog.HandlerOptions{
                ReplaceAttr: func(groups []string, a slog.Attr) slog.Attr </span><span class="cov0" title="0">{
                        // Anything other than time key
                        // return
                        if a.Key != slog.TimeKey </span><span class="cov0" title="0">{
                                return a
                        }</span>
                        <span class="cov0" title="0">return slog.String(
                                slog.TimeKey,
                                a.Value.Time().Format("2006-01-02T15:04:05.000Z"),
                        )</span>
                },
                Level: levelVar,
        })

        <span class="cov0" title="0">slogAttrs := []slog.Attr{
                {
                        Key:   "pkg",
                        Value: slog.StringValue(pkgName),
                },
        }
        for _, attr := range attrs </span><span class="cov0" title="0">{
                slogAttrs = append(slogAttrs, slog.Attr{
                        Key:   attr.Key,
                        Value: slog.StringValue(attr.Value),
                })
        }</span>

        <span class="cov0" title="0">return &amp;Logger{slog.New(h.WithAttrs(slogAttrs))}</span>
}

func SetLogLevel(l slog.Level) <span class="cov0" title="0">{
        levelVar.Set(l)
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package provider

import (
        "context"
        "fmt"

        "github.com/rudderlabs/rudder-iac/api/client/catalog"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/state"
        "github.com/rudderlabs/rudder-iac/cli/pkg/logger"
)

const (
        PropertyResourceType     = "property"
        EventResourceType        = "event"
        TrackingPlanResourceType = "tracking-plan"
        CustomTypeResourceType   = "custom-type"
)

var (
        log = logger.New("catalog-provider")
)

var resourceTypeCollection = map[string]catalog.ResourceCollection{
        PropertyResourceType:     catalog.ResourceCollectionProperties,
        EventResourceType:        catalog.ResourceCollectionEvents,
        TrackingPlanResourceType: catalog.ResourceCollectionTrackingPlans,
        CustomTypeResourceType:   catalog.ResourceCollectionCustomTypes,
}

type CatalogProvider struct {
        client        catalog.DataCatalog
        providerStore map[string]resourceProvider
}

type resourceProvider interface {
        Create(ctx context.Context, ID string, data resources.ResourceData) (*resources.ResourceData, error)
        Update(ctx context.Context, ID string, data resources.ResourceData, state resources.ResourceData) (*resources.ResourceData, error)
        Delete(ctx context.Context, ID string, state resources.ResourceData) error
}

func NewCatalogProvider(dc catalog.DataCatalog) syncer.SyncProvider <span class="cov0" title="0">{
        return &amp;CatalogProvider{
                client: dc,
                providerStore: map[string]resourceProvider{
                        PropertyResourceType:     NewPropertyProvider(dc),
                        EventResourceType:        NewEventProvider(dc),
                        TrackingPlanResourceType: NewTrackingPlanProvider(dc),
                        CustomTypeResourceType:   NewCustomTypeProvider(dc),
                },
        }
}</span>

func (p *CatalogProvider) LoadState(ctx context.Context) (*state.State, error) <span class="cov0" title="0">{
        cs, err := p.client.ReadState(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">s := &amp;state.State{
                Version:   cs.Version,
                Resources: make(map[string]*state.ResourceState),
        }

        for id, rs := range cs.Resources </span><span class="cov0" title="0">{
                decodedState := state.DecodeResourceState(&amp;state.ResourceState{
                        ID:           rs.ID,
                        Type:         rs.Type,
                        Input:        rs.Input,
                        Output:       rs.Output,
                        Dependencies: rs.Dependencies,
                })
                s.Resources[id] = decodedState
        }</span>

        <span class="cov0" title="0">return s, nil</span>
}

func (p *CatalogProvider) PutResourceState(ctx context.Context, URN string, s *state.ResourceState) error <span class="cov0" title="0">{
        encodedState := state.EncodeResourceState(s)

        remoteID := s.Output["id"].(string)
        return p.client.PutResourceState(ctx, catalog.PutStateRequest{
                Collection: resourceTypeCollection[s.Type],
                ID:         remoteID,
                URN:        URN,
                State: catalog.ResourceState{
                        ID:           encodedState.ID,
                        Type:         encodedState.Type,
                        Input:        encodedState.Input,
                        Output:       encodedState.Output,
                        Dependencies: encodedState.Dependencies,
                },
        })
}</span>

func (p *CatalogProvider) DeleteResourceState(ctx context.Context, s *state.ResourceState) error <span class="cov0" title="0">{
        remoteID := s.Output["id"].(string)
        return p.client.DeleteResourceState(ctx, catalog.DeleteStateRequest{
                Collection: resourceTypeCollection[s.Type],
                ID:         remoteID,
        })
}</span>

func (p *CatalogProvider) Create(ctx context.Context, ID string, resourceType string, data resources.ResourceData) (*resources.ResourceData, error) <span class="cov0" title="0">{
        provider, ok := p.providerStore[resourceType]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unknown resource type: %s", resourceType)
        }</span>
        <span class="cov0" title="0">return provider.Create(ctx, ID, data)</span>
}

func (p *CatalogProvider) Update(ctx context.Context, ID string, resourceType string, data resources.ResourceData, state resources.ResourceData) (*resources.ResourceData, error) <span class="cov0" title="0">{
        provider, ok := p.providerStore[resourceType]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unknown resource type: %s", resourceType)
        }</span>
        <span class="cov0" title="0">return provider.Update(ctx, ID, data, state)</span>
}

func (p *CatalogProvider) Delete(ctx context.Context, ID string, resourceType string, state resources.ResourceData) error <span class="cov0" title="0">{
        provider, ok := p.providerStore[resourceType]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("unknown resource type: %s", resourceType)
        }</span>
        <span class="cov0" title="0">return provider.Delete(ctx, ID, state)</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package provider

import (
        "context"
        "fmt"

        "github.com/rudderlabs/rudder-iac/api/client/catalog"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
        "github.com/rudderlabs/rudder-iac/cli/pkg/logger"
        "github.com/rudderlabs/rudder-iac/cli/pkg/provider/state"
)

type CustomTypeProvider struct {
        client catalog.DataCatalog
        log    logger.Logger
}

func NewCustomTypeProvider(dc catalog.DataCatalog) *CustomTypeProvider <span class="cov0" title="0">{
        return &amp;CustomTypeProvider{
                client: dc,
                log: logger.Logger{
                        Logger: logger.New("provider").With("type", "customtype"),
                },
        }
}</span>

func (p *CustomTypeProvider) Create(ctx context.Context, ID string, data resources.ResourceData) (*resources.ResourceData, error) <span class="cov0" title="0">{
        p.log.Debug("creating custom type in upstream catalog", "id", ID)

        toArgs := state.CustomTypeArgs{}
        toArgs.FromResourceData(data)

        properties := make([]catalog.CustomTypeProperty, 0, len(toArgs.Properties))
        for _, prop := range toArgs.Properties </span><span class="cov0" title="0">{
                properties = append(properties, catalog.CustomTypeProperty{
                        ID:       prop.ID,
                        Required: prop.Required,
                })
        }</span>

        <span class="cov0" title="0">input := catalog.CustomTypeCreate{
                Name:        toArgs.Name,
                Description: toArgs.Description,
                Type:        toArgs.Type,
                Config:      toArgs.Config,
                Properties:  properties,
        }

        customType, err := p.client.CreateCustomType(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating custom type: %w", err)
        }</span>

        <span class="cov0" title="0">customTypeState := state.CustomTypeState{
                CustomTypeArgs:  toArgs,
                ID:              customType.ID,
                LocalID:         toArgs.LocalID,
                Name:            customType.Name,
                Description:     customType.Description,
                Type:            customType.Type,
                Config:          customType.Config,
                Version:         customType.Version,
                ItemDefinitions: customType.ItemDefinitions,
                Rules:           customType.Rules,
                WorkspaceID:     customType.WorkspaceId,
                CreatedAt:       customType.CreatedAt.String(),
                UpdatedAt:       customType.UpdatedAt.String(),
        }

        resourceData := customTypeState.ToResourceData()
        return &amp;resourceData, nil</span>
}

func (p *CustomTypeProvider) Update(ctx context.Context, ID string, input resources.ResourceData, olds resources.ResourceData) (*resources.ResourceData, error) <span class="cov0" title="0">{
        p.log.Debug("updating custom type in upstream catalog", "id", ID)

        toArgs := state.CustomTypeArgs{}
        toArgs.FromResourceData(input)

        oldState := state.CustomTypeState{}
        oldState.FromResourceData(olds)

        properties := make([]catalog.CustomTypeProperty, 0, len(toArgs.Properties))
        for _, prop := range toArgs.Properties </span><span class="cov0" title="0">{
                properties = append(properties, catalog.CustomTypeProperty{
                        ID:       prop.ID,
                        Required: prop.Required,
                })
        }</span>

        <span class="cov0" title="0">updated, err := p.client.UpdateCustomType(ctx, oldState.ID, &amp;catalog.CustomType{
                ID:          oldState.ID,
                Name:        toArgs.Name,
                Description: toArgs.Description,
                Type:        toArgs.Type,
                Config:      toArgs.Config,
                Properties:  properties,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("updating custom type resource in upstream catalog: %w", err)
        }</span>

        <span class="cov0" title="0">toState := state.CustomTypeState{
                CustomTypeArgs:  toArgs,
                ID:              updated.ID,
                LocalID:         toArgs.LocalID,
                Name:            updated.Name,
                Description:     updated.Description,
                Type:            updated.Type,
                Config:          updated.Config,
                Version:         updated.Version,
                ItemDefinitions: updated.ItemDefinitions,
                Rules:           updated.Rules,
                WorkspaceID:     updated.WorkspaceId,
                CreatedAt:       updated.CreatedAt.String(),
                UpdatedAt:       updated.UpdatedAt.String(),
        }

        resourceData := toState.ToResourceData()
        return &amp;resourceData, nil</span>
}

func (p *CustomTypeProvider) Delete(ctx context.Context, ID string, data resources.ResourceData) error <span class="cov0" title="0">{
        p.log.Debug("deleting custom type in upstream catalog", "id", ID)

        err := p.client.DeleteCustomType(ctx, data["id"].(string))
        if err != nil &amp;&amp; !catalog.IsCatalogNotFoundError(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("deleting custom type resource in upstream catalog: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package provider

import (
        "context"
        "fmt"

        "github.com/rudderlabs/rudder-iac/api/client/catalog"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
        "github.com/rudderlabs/rudder-iac/cli/pkg/logger"
        "github.com/rudderlabs/rudder-iac/cli/pkg/provider/state"
)

// TODO: implement on the same lines as the propertyProvider
type EventProvider struct {
        catalog catalog.DataCatalog
        log     *logger.Logger
}

func NewEventProvider(catalog catalog.DataCatalog) *EventProvider <span class="cov8" title="1">{
        return &amp;EventProvider{
                catalog: catalog,
                log: &amp;logger.Logger{
                        Logger: log.With("type", "event"),
                },
        }
}</span>

func (p *EventProvider) Create(ctx context.Context, ID string, data resources.ResourceData) (*resources.ResourceData, error) <span class="cov8" title="1">{
        p.log.Debug("creating event in upstream catalog", "id", ID)

        toArgs := state.EventArgs{}
        toArgs.FromResourceData(data)

        event, err := p.catalog.CreateEvent(ctx, catalog.EventCreate{
                Name:        toArgs.Name,
                Description: toArgs.Description,
                EventType:   toArgs.EventType,
                CategoryId:  toArgs.CategoryID,
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating event in upstream catalog: %w", err)
        }</span>

        <span class="cov8" title="1">eventState := state.EventState{
                EventArgs:   toArgs,
                ID:          event.ID,
                Name:        event.Name,
                Description: event.Description,
                EventType:   event.EventType,
                WorkspaceID: event.WorkspaceId,
                CategoryID:  event.CategoryId,
                CreatedAt:   event.CreatedAt.String(),
                UpdatedAt:   event.UpdatedAt.String(),
        }

        resourceData := eventState.ToResourceData()

        return &amp;resourceData, nil</span>
}

func (p *EventProvider) Update(ctx context.Context, ID string, input resources.ResourceData, olds resources.ResourceData) (*resources.ResourceData, error) <span class="cov8" title="1">{
        p.log.Debug("updating event in upstream catalog", "id", ID)

        toArgs := state.EventArgs{}
        toArgs.FromResourceData(input)

        prevState := state.EventState{}
        prevState.FromResourceData(olds)

        updatedEvent, err := p.catalog.UpdateEvent(ctx, prevState.ID, &amp;catalog.Event{
                Name:        toArgs.Name,
                Description: toArgs.Description,
                EventType:   toArgs.EventType,
                WorkspaceId: prevState.WorkspaceID,
                CategoryId:  toArgs.CategoryID,
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("updating event in upstream catalog: %w", err)
        }</span>

        <span class="cov8" title="1">toState := state.EventState{
                EventArgs:   toArgs,
                ID:          updatedEvent.ID,
                Name:        updatedEvent.Name,
                Description: updatedEvent.Description,
                EventType:   updatedEvent.EventType,
                WorkspaceID: updatedEvent.WorkspaceId,
                CategoryID:  updatedEvent.CategoryId,
                CreatedAt:   updatedEvent.CreatedAt.String(),
                UpdatedAt:   updatedEvent.UpdatedAt.String(),
        }

        resourceData := toState.ToResourceData()
        return &amp;resourceData, nil</span>
}

func (p *EventProvider) Delete(ctx context.Context, ID string, state resources.ResourceData) error <span class="cov8" title="1">{
        p.log.Debug("deleting event in upstream catalog", "id", ID)

        remoteID := state["id"].(string)
        err := p.catalog.DeleteEvent(ctx, remoteID)
        if err != nil &amp;&amp; !catalog.IsCatalogNotFoundError(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("deleting event in upstream catalog: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package provider

import (
        "context"
        "fmt"

        "github.com/rudderlabs/rudder-iac/api/client/catalog"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
        "github.com/rudderlabs/rudder-iac/cli/pkg/logger"
        "github.com/rudderlabs/rudder-iac/cli/pkg/provider/state"
)

type PropertyProvider struct {
        client catalog.DataCatalog
        log    logger.Logger
}

func NewPropertyProvider(dc catalog.DataCatalog) *PropertyProvider <span class="cov8" title="1">{
        return &amp;PropertyProvider{
                client: dc,
                log: logger.Logger{
                        Logger: logger.New("provider").With("type", "property"),
                },
        }
}</span>

func (p *PropertyProvider) Create(ctx context.Context, ID string, data resources.ResourceData) (*resources.ResourceData, error) <span class="cov8" title="1">{
        p.log.With("provider", "property").Debug("creating property resource in upstream catalog", "id", ID)

        toArgs := state.PropertyArgs{}
        toArgs.FromResourceData(data)

        property, err := p.client.CreateProperty(ctx, catalog.PropertyCreate{
                Name:        toArgs.Name,
                Description: toArgs.Description,
                Type:        toArgs.Type.(string),
                Config:      toArgs.Config,
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating property resource in upstream catalog: %w", err)
        }</span>

        <span class="cov8" title="1">propertyState := state.PropertyState{
                PropertyArgs: toArgs,
                ID:           property.ID,
                Name:         property.Name,
                Description:  property.Description,
                Type:         property.Type,
                Config:       property.Config,
                WorkspaceID:  property.WorkspaceId,
                CreatedAt:    property.CreatedAt.UTC().String(),
                UpdatedAt:    property.UpdatedAt.UTC().String(),
        }

        resourceData := propertyState.ToResourceData()
        return &amp;resourceData, nil</span>
}

func (p *PropertyProvider) Update(ctx context.Context, ID string, input resources.ResourceData, olds resources.ResourceData) (*resources.ResourceData, error) <span class="cov8" title="1">{
        p.log.Debug("updating property resource in upstream catalog", "id", ID)

        toArgs := state.PropertyArgs{}
        toArgs.FromResourceData(input)

        oldState := state.PropertyState{}
        oldState.FromResourceData(olds)

        updated, err := p.client.UpdateProperty(ctx, oldState.ID, &amp;catalog.Property{
                ID:          oldState.ID,
                Name:        toArgs.Name,
                Description: toArgs.Description,
                Type:        toArgs.Type.(string),
                Config:      toArgs.Config,
                WorkspaceId: oldState.WorkspaceID,
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("updating property resource in upstream catalog: %w", err)
        }</span>

        <span class="cov8" title="1">toState := state.PropertyState{
                PropertyArgs: toArgs,
                ID:           updated.ID,
                Name:         updated.Name,
                Description:  updated.Description,
                Type:         updated.Type,
                Config:       updated.Config,
                WorkspaceID:  updated.WorkspaceId,
                CreatedAt:    updated.CreatedAt.String(),
                UpdatedAt:    updated.UpdatedAt.String(),
        }

        resourceData := toState.ToResourceData()
        return &amp;resourceData, nil</span>
}

func (p *PropertyProvider) Delete(ctx context.Context, ID string, data resources.ResourceData) error <span class="cov8" title="1">{
        p.log.Debug("deleting property resource in upstream catalog", "id", ID)

        err := p.client.DeleteProperty(ctx, data["id"].(string))

        if err != nil &amp;&amp; !catalog.IsCatalogNotFoundError(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("deleting property resource in upstream catalog: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package state

import (
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
        "github.com/rudderlabs/rudder-iac/cli/pkg/localcatalog"
)

// CustomTypeArgs holds the necessary information to create a custom type
type CustomTypeArgs struct {
        LocalID     string
        Name        string
        Description string
        Type        string
        Config      map[string]any
        Properties  []*CustomTypeProperty // For object-type custom types
}

// CustomTypeProperty represents a property reference in a custom type
type CustomTypeProperty struct {
        RefToID  any
        ID       string
        Required bool
}

// ToResourceData converts CustomTypeArgs to ResourceData for use in the resource graph
func (args *CustomTypeArgs) ToResourceData() resources.ResourceData <span class="cov8" title="1">{
        properties := make([]map[string]any, 0, len(args.Properties))
        for _, prop := range args.Properties </span><span class="cov8" title="1">{
                properties = append(properties, map[string]any{
                        "refToId":  prop.RefToID,
                        "id":       prop.ID,
                        "required": prop.Required,
                })
        }</span>

        <span class="cov8" title="1">return resources.ResourceData{
                "localId":     args.LocalID,
                "name":        args.Name,
                "description": args.Description,
                "type":        args.Type,
                "config":      args.Config,
                "properties":  properties,
        }</span>
}

// FromResourceData populates CustomTypeArgs from ResourceData
func (args *CustomTypeArgs) FromResourceData(from resources.ResourceData) <span class="cov8" title="1">{
        args.LocalID = MustString(from, "localId")
        args.Name = MustString(from, "name")
        args.Description = MustString(from, "description")
        args.Type = MustString(from, "type")
        args.Config = MapStringInterface(from, "config", make(map[string]any))

        // Handle properties array using similar pattern to TrackingPlan
        var properties []any

        // Try both patterns to handle different data structures
        properties = InterfaceSlice(from, "properties", nil)
        if len(properties) == 0 </span><span class="cov8" title="1">{
                propertiesMap := MapStringInterfaceSlice(from, "properties", nil)
                for _, prop := range propertiesMap </span><span class="cov8" title="1">{
                        properties = append(properties, prop)
                }</span>
        }

        // Create properties array
        <span class="cov8" title="1">customTypeProperties := make([]*CustomTypeProperty, len(properties))
        for idx, prop := range properties </span><span class="cov8" title="1">{
                propMap := prop.(map[string]any)

                inst := &amp;CustomTypeProperty{
                        Required: MustBool(propMap, "required"),
                        ID:       MustString(propMap, "id"),
                        RefToID:  MustString(propMap, "refToId"),
                }
                inst.ID = inst.RefToID.(string)
                customTypeProperties[idx] = inst
        }</span>

        <span class="cov8" title="1">args.Properties = customTypeProperties</span>
}

func (args *CustomTypeArgs) FromCatalogCustomType(from *localcatalog.CustomType, urnFromRef func(urn string) string) <span class="cov8" title="1">{
        args.LocalID = from.LocalID
        args.Name = from.Name
        args.Description = from.Description
        args.Type = from.Type
        args.Config = from.Config

        properties := make([]*CustomTypeProperty, 0, len(from.Properties))
        for _, prop := range from.Properties </span><span class="cov8" title="1">{
                properties = append(properties, &amp;CustomTypeProperty{
                        RefToID: resources.PropertyRef{
                                URN:      urnFromRef(prop.Ref),
                                Property: "id",
                        },
                        Required: prop.Required,
                })
        }</span>

        // BUGGY CODE TO BE FIXED IN A BETTER
        <span class="cov8" title="1">itemTypes, ok := args.Config["itemTypes"]
        if ok </span><span class="cov0" title="0">{

                for idx, item := range itemTypes.([]any) </span><span class="cov0" title="0">{

                        if !localcatalog.CustomTypeRegex.Match([]byte(item.(string))) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">typesWithPropRef := make([]any, len(itemTypes.([]any)))
                        typesWithPropRef[idx] = resources.PropertyRef{
                                URN:      urnFromRef(item.(string)),
                                Property: "name",
                        }

                        args.Config["itemTypes"] = typesWithPropRef</span>
                }

        }

        <span class="cov8" title="1">args.Properties = properties</span>
}

type CustomTypeState struct {
        CustomTypeArgs
        ID              string
        LocalID         string
        Name            string
        Description     string
        Type            string
        Config          map[string]any
        Version         int
        ItemDefinitions []string
        Rules           map[string]any
        WorkspaceID     string
        CreatedAt       string
        UpdatedAt       string
}

type CustomTypePropertyState struct {
        ID       string
        Required bool
}

func (s *CustomTypeState) ToResourceData() resources.ResourceData <span class="cov0" title="0">{

        return resources.ResourceData{
                "id":              s.ID,
                "localId":         s.LocalID,
                "name":            s.Name,
                "description":     s.Description,
                "type":            s.Type,
                "config":          s.Config,
                "version":         s.Version,
                "itemDefinitions": s.ItemDefinitions,
                "rules":           s.Rules,
                "workspaceId":     s.WorkspaceID,
                "createdAt":       s.CreatedAt,
                "updatedAt":       s.UpdatedAt,
                "customTypeArgs":  map[string]interface{}(s.CustomTypeArgs.ToResourceData()),
        }
}</span>

func (s *CustomTypeState) FromResourceData(from resources.ResourceData) <span class="cov0" title="0">{
        s.ID = MustString(from, "id")
        s.LocalID = MustString(from, "localId")
        s.Name = MustString(from, "name")
        s.Description = MustString(from, "description")
        s.Type = MustString(from, "type")
        s.Config = MapStringInterface(from, "config", make(map[string]any))
        s.Version = int(MustFloat64(from, "version"))
        s.ItemDefinitions = MustStringSlice(from, "itemDefinitions")
        s.Rules = MapStringInterface(from, "rules", make(map[string]any))
        s.WorkspaceID = MustString(from, "workspaceId")
        s.CreatedAt = MustString(from, "createdAt")
        s.UpdatedAt = MustString(from, "updatedAt")

        s.CustomTypeArgs.FromResourceData(
                MustMapStringInterface(from, "customTypeArgs"),
        )
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package state

import "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"

type EventArgs struct {
        Name        string
        Description string
        EventType   string
        CategoryID  *string
}

func (args *EventArgs) ToResourceData() resources.ResourceData <span class="cov8" title="1">{
        return resources.ResourceData{
                "name":        args.Name,
                "description": args.Description,
                "eventType":   args.EventType,
                "categoryId":  args.CategoryID,
        }
}</span>

func (args *EventArgs) FromResourceData(from resources.ResourceData) <span class="cov8" title="1">{
        args.Name = MustString(from, "name")
        args.Description = MustString(from, "description")
        args.EventType = MustString(from, "eventType")
        args.CategoryID = StringPtr(from, "categoryId", nil)
}</span>

type EventState struct {
        EventArgs
        ID          string
        Name        string
        Description string
        EventType   string
        WorkspaceID string
        CategoryID  *string
        CreatedAt   string
        UpdatedAt   string
}

func (e *EventState) ToResourceData() resources.ResourceData <span class="cov8" title="1">{
        return resources.ResourceData{
                "id":          e.ID,
                "name":        e.Name,
                "description": e.Description,
                "eventType":   e.EventType,
                "workspaceId": e.WorkspaceID,
                "categoryId":  e.CategoryID,
                "createdAt":   e.CreatedAt,
                "updatedAt":   e.UpdatedAt,
                "eventArgs":   map[string]interface{}(e.EventArgs.ToResourceData()),
        }
}</span>

func (e *EventState) FromResourceData(from resources.ResourceData) <span class="cov8" title="1">{
        e.ID = MustString(from, "id")
        e.Name = MustString(from, "name")
        e.Description = MustString(from, "description")
        e.EventType = MustString(from, "eventType")
        e.WorkspaceID = MustString(from, "workspaceId")
        e.CreatedAt = MustString(from, "createdAt")
        e.UpdatedAt = MustString(from, "updatedAt")
        e.CategoryID = StringPtr(from, "categoryId", nil)
        e.EventArgs.FromResourceData(resources.ResourceData(
                MustMapStringInterface(from, "eventArgs"),
        ))
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package state

import (
        "fmt"
        "strings"

        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
        "github.com/rudderlabs/rudder-iac/cli/pkg/localcatalog"
)

type PropertyArgs struct {
        Name        string
        Description string
        Type        any
        Config      map[string]interface{}
}

func (args *PropertyArgs) FromCatalogPropertyType(prop localcatalog.Property, urnFromRef func(string) string) error <span class="cov8" title="1">{
        args.Name = prop.Name
        args.Description = prop.Description
        args.Type = prop.Type
        args.Config = prop.Config

        if strings.HasPrefix(prop.Type, "#/custom-types/") </span><span class="cov8" title="1">{
                customTypeURN := urnFromRef(prop.Type)

                if customTypeURN == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to resolve custom type reference urn: %s", prop.Type)
                }</span>
                <span class="cov8" title="1">args.Type = resources.PropertyRef{
                        URN:      customTypeURN,
                        Property: "name",
                }</span>
        }

        <span class="cov8" title="1">if prop.Type == "array" &amp;&amp; prop.Config != nil </span><span class="cov8" title="1">{
                itemTypes, ok := prop.Config["itemTypes"]
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">for _, item := range itemTypes.([]any) </span><span class="cov8" title="1">{
                        val := item.(string)

                        if !strings.HasPrefix(val, "#/custom-types/") </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">customTypeURN := urnFromRef(val)
                        if customTypeURN == "" </span><span class="cov8" title="1">{
                                return fmt.Errorf("unable to resolve ref to the custom type urn: %s", val)
                        }</span>

                        <span class="cov8" title="1">args.Config["itemTypes"] = []interface{}{
                                resources.PropertyRef{
                                        URN:      customTypeURN,
                                        Property: "name",
                                },
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (args *PropertyArgs) ToResourceData() resources.ResourceData <span class="cov8" title="1">{
        return resources.ResourceData{
                "name":        args.Name,
                "description": args.Description,
                "type":        args.Type,
                "config":      args.Config,
        }
}</span>

func (args *PropertyArgs) FromResourceData(from resources.ResourceData) <span class="cov8" title="1">{
        args.Name = MustString(from, "name")
        args.Description = MustString(from, "description")
        args.Type = MustString(from, "type")
        args.Config = MapStringInterface(from, "config", make(map[string]interface{}))
}</span>

type PropertyState struct {
        PropertyArgs
        ID          string
        Name        string
        Description string
        Type        string
        WorkspaceID string
        Config      map[string]interface{}
        CreatedAt   string
        UpdatedAt   string
}

func (p *PropertyState) ToResourceData() resources.ResourceData <span class="cov8" title="1">{
        return resources.ResourceData{
                "id":           p.ID,
                "name":         p.Name,
                "description":  p.Description,
                "type":         p.Type,
                "config":       p.Config,
                "workspaceId":  p.WorkspaceID,
                "createdAt":    p.CreatedAt,
                "updatedAt":    p.UpdatedAt,
                "propertyArgs": map[string]interface{}(p.PropertyArgs.ToResourceData()),
        }
}</span>

func (p *PropertyState) FromResourceData(from resources.ResourceData) <span class="cov8" title="1">{
        p.ID = MustString(from, "id")
        p.Name = MustString(from, "name")
        p.Description = MustString(from, "description")
        p.Type = MustString(from, "type")
        p.Config = MapStringInterface(from, "config", make(map[string]interface{}))
        p.WorkspaceID = MustString(from, "workspaceId")
        p.CreatedAt = MustString(from, "createdAt")
        p.UpdatedAt = MustString(from, "updatedAt")

        p.PropertyArgs.FromResourceData(
                MustMapStringInterface(from, "propertyArgs"),
        )
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package state

import (
        "fmt"
        "strings"

        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
        "github.com/rudderlabs/rudder-iac/cli/pkg/localcatalog"
)

const (
        PropertiesIdentity    = "properties"
        TraitsIdentity        = "traits"
        ContextTraitsIdentity = "context.traits"
)

type TrackingPlanState struct {
        TrackingPlanArgs
        ID           string
        Name         string
        Description  string
        Version      int
        CreationType string
        WorkspaceID  string
        CreatedAt    string
        UpdatedAt    string
        Events       []*TrackingPlanEventState
}

func (t *TrackingPlanState) LocalIDForCatalogEventID(eventID string) string <span class="cov0" title="0">{
        for _, event := range t.Events </span><span class="cov0" title="0">{
                if event.EventID == eventID </span><span class="cov0" title="0">{
                        return event.LocalID
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func (t *TrackingPlanState) CatalogEventIDForLocalID(localID string) string <span class="cov0" title="0">{
        for _, event := range t.Events </span><span class="cov0" title="0">{
                if event.LocalID == localID </span><span class="cov0" title="0">{
                        return event.EventID
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

type TrackingPlanEventState struct {
        ID      string
        LocalID string
        EventID string
}

func (t *TrackingPlanState) EventByLocalID(localID string) *TrackingPlanEventState <span class="cov0" title="0">{
        for _, event := range t.Events </span><span class="cov0" title="0">{
                if event.LocalID == localID </span><span class="cov0" title="0">{
                        return event
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type TrackingPlanPropertyState struct {
        Name        string
        LocalID     string
        Description string
        Type        string
        Config      map[string]interface{}
        Required    bool
}

type TrackingPlanArgsDiff struct {
        Added   []*TrackingPlanEventArgs
        Updated []*TrackingPlanEventArgs
        Deleted []*TrackingPlanEventArgs
}

func (t *TrackingPlanState) ToResourceData() resources.ResourceData <span class="cov0" title="0">{

        var (
                events []map[string]interface{}
        )

        for _, event := range t.Events </span><span class="cov0" title="0">{

                events = append(events, map[string]interface{}{
                        "id":      event.ID,
                        "eventId": event.EventID,
                        "localId": event.LocalID,
                })
        }</span>

        <span class="cov0" title="0">return resources.ResourceData{
                "id":               t.ID,
                "name":             t.Name,
                "description":      t.Description,
                "version":          t.Version,
                "creationType":     t.CreationType,
                "workspaceId":      t.WorkspaceID,
                "createdAt":        t.CreatedAt,
                "updatedAt":        t.UpdatedAt,
                "events":           events,
                "trackingPlanArgs": map[string]interface{}(t.TrackingPlanArgs.ToResourceData()),
        }</span>
}

func (t *TrackingPlanState) FromResourceData(from resources.ResourceData) <span class="cov0" title="0">{

        t.ID = MustString(from, "id")
        t.Name = MustString(from, "name")
        t.Description = MustString(from, "description")
        t.Version = int(MustFloat64(from, "version"))
        t.CreationType = MustString(from, "creationType")
        t.WorkspaceID = MustString(from, "workspaceId")
        t.CreatedAt = MustString(from, "createdAt")
        t.UpdatedAt = MustString(from, "updatedAt")
        t.TrackingPlanArgs.FromResourceData(
                MustMapStringInterface(from, "trackingPlanArgs"),
        )

        events := InterfaceSlice(from, "events", nil)
        if len(events) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tpEvents := make([]*TrackingPlanEventState, len(events))
        for idx, event := range events </span><span class="cov0" title="0">{
                event := event.(map[string]interface{})

                tpEvents[idx] = &amp;TrackingPlanEventState{
                        ID:      MustString(event, "id"),
                        EventID: MustString(event, "eventId"),
                        LocalID: MustString(event, "localId"),
                }
        }</span>

        <span class="cov0" title="0">t.Events = tpEvents</span>
}

// Encapsulates the catalog argument which is added as a resource
// when registering the tracking plan
type TrackingPlanArgs struct {
        Name        string
        LocalID     string
        Description string
        Events      []*TrackingPlanEventArgs
}

func (args TrackingPlanArgs) Diff(other TrackingPlanArgs) *TrackingPlanArgsDiff <span class="cov8" title="1">{

        diffed := &amp;TrackingPlanArgsDiff{
                Added:   make([]*TrackingPlanEventArgs, 0),
                Updated: make([]*TrackingPlanEventArgs, 0),
                Deleted: make([]*TrackingPlanEventArgs, 0),
        }

        for _, otherEvent := range other.Events </span><span class="cov8" title="1">{
                if args.EventByLocalID(otherEvent.LocalID) == nil </span><span class="cov8" title="1">{
                        diffed.Added = append(diffed.Added, otherEvent)
                }</span>
        }

        <span class="cov8" title="1">for _, event := range args.Events </span><span class="cov8" title="1">{

                otherEvent := other.EventByLocalID(event.LocalID)

                if otherEvent == nil </span><span class="cov8" title="1">{
                        diffed.Deleted = append(diffed.Deleted, event)
                        continue</span>
                }

                <span class="cov8" title="1">if event.Diff(otherEvent) </span><span class="cov8" title="1">{
                        diffed.Updated = append(diffed.Updated, otherEvent)
                }</span>

        }

        <span class="cov8" title="1">return diffed</span>
}

type TrackingPlanEventArgs struct {
        Name            string
        LocalID         string
        Description     string
        Type            string
        AllowUnplanned  bool
        IdentitySection string
        Properties      []*TrackingPlanPropertyArgs
}

func (args *TrackingPlanEventArgs) Diff(other *TrackingPlanEventArgs) bool <span class="cov8" title="1">{
        if args.LocalID != other.LocalID </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if args.AllowUnplanned != other.AllowUnplanned </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if args.IdentitySection != other.IdentitySection </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if len(args.Properties) != len(other.Properties) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">for _, prop := range args.Properties </span><span class="cov8" title="1">{

                otherProp := other.PropertyByLocalID(prop.LocalID)
                if otherProp == nil </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov8" title="1">if prop.Diff(otherProp) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func (args *TrackingPlanEventArgs) PropertyByLocalID(id string) *TrackingPlanPropertyArgs <span class="cov8" title="1">{
        for _, prop := range args.Properties </span><span class="cov8" title="1">{
                if prop.LocalID == id </span><span class="cov8" title="1">{
                        return prop
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type TrackingPlanPropertyArgs struct {
        Name             string
        LocalID          string
        Description      string
        Type             any
        Config           map[string]interface{}
        Required         bool
        HasCustomTypeRef bool
        HasItemTypesRef  bool
}

func (args *TrackingPlanPropertyArgs) Diff(other *TrackingPlanPropertyArgs) bool <span class="cov8" title="1">{
        if args.LocalID != other.LocalID </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">return args.Required != other.Required</span>
}

func (args *TrackingPlanPropertyArgs) FromCatalogTrackingPlanEventProperty(prop *localcatalog.TPEventProperty, urnFromRef func(string) string) error <span class="cov8" title="1">{
        args.Name = prop.Name
        args.Description = prop.Description
        args.LocalID = prop.LocalID
        args.Required = prop.Required
        args.Type = prop.Type
        args.Config = prop.Config
        args.HasCustomTypeRef = false
        args.HasItemTypesRef = false

        // Check if Type is a custom type reference
        if strings.HasPrefix(prop.Type, "#/custom-types/") </span><span class="cov8" title="1">{
                customTypeURN := urnFromRef(prop.Type)
                if customTypeURN == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("unable to resolve custom type reference urn: %s", prop.Type)
                }</span>

                <span class="cov8" title="1">args.Type = resources.PropertyRef{
                        URN:      customTypeURN,
                        Property: "name",
                }
                args.HasCustomTypeRef = true</span>
        }

        // Check if Config has itemTypes with custom type reference
        <span class="cov8" title="1">if prop.Config != nil </span><span class="cov8" title="1">{
                if itemTypes, ok := prop.Config["itemTypes"].([]any); ok &amp;&amp; len(itemTypes) &gt; 0 </span><span class="cov8" title="1">{
                        val := itemTypes[0].(string)

                        if strings.HasPrefix(val, "#/custom-types/") </span><span class="cov8" title="1">{
                                customTypeURN := urnFromRef(val)
                                if customTypeURN == "" </span><span class="cov8" title="1">{
                                        return fmt.Errorf("unable to resolve custom type reference urn in itemTypes: %s", val)
                                }</span>

                                <span class="cov8" title="1">args.Config["itemTypes"] = []any{
                                        resources.PropertyRef{
                                                URN:      customTypeURN,
                                                Property: "name",
                                        },
                                }
                                args.HasItemTypesRef = true</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (args *TrackingPlanArgs) FromCatalogTrackingPlan(from *localcatalog.TrackingPlan, urnFromRef func(string) string) error <span class="cov0" title="0">{
        args.Name = from.Name
        args.LocalID = from.LocalID
        args.Description = from.Description

        events := make([]*TrackingPlanEventArgs, 0, len(from.EventProps))
        for _, event := range from.EventProps </span><span class="cov0" title="0">{
                properties := make([]*TrackingPlanPropertyArgs, 0, len(event.Properties))

                for _, prop := range event.Properties </span><span class="cov0" title="0">{
                        tpProperty := &amp;TrackingPlanPropertyArgs{}

                        if err := tpProperty.FromCatalogTrackingPlanEventProperty(
                                prop,
                                urnFromRef,
                        ); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("processing property %s: %w", prop.LocalID, err)
                        }</span>

                        <span class="cov0" title="0">properties = append(properties, tpProperty)</span>
                }

                <span class="cov0" title="0">events = append(events, &amp;TrackingPlanEventArgs{
                        Name:            event.Name,
                        LocalID:         event.LocalID,
                        Description:     event.Description,
                        Type:            event.Type,
                        AllowUnplanned:  event.AllowUnplanned,
                        IdentitySection: event.IdentitySection,
                        Properties:      properties,
                })</span>
        }

        <span class="cov0" title="0">args.Events = events
        return nil</span>
}

func (args *TrackingPlanArgs) EventByLocalID(id string) *TrackingPlanEventArgs <span class="cov8" title="1">{

        for _, event := range args.Events </span><span class="cov8" title="1">{
                if event.LocalID == id </span><span class="cov8" title="1">{
                        return event
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (args *TrackingPlanArgs) PropertyByLocalID(eventID, id string) *TrackingPlanPropertyArgs <span class="cov0" title="0">{
        event := args.EventByLocalID(eventID)
        if event == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, property := range event.Properties </span><span class="cov0" title="0">{
                if property.LocalID == id </span><span class="cov0" title="0">{
                        return property
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (args *TrackingPlanArgs) FromResourceData(from resources.ResourceData) <span class="cov0" title="0">{

        args.Name = MustString(from, "name")
        args.Description = MustString(from, "description")
        args.LocalID = MustString(from, "localId")

        var (
                events []interface{}
        )

        // When loading the args from the state []map[string]interface{} is treated as []interface{}
        // but when we have events from catalog being registered as a resource, it is []map[string]interface{}
        events = InterfaceSlice(from, "events", nil)
        if len(events) == 0 </span><span class="cov0" title="0">{
                eventsMap := MapStringInterfaceSlice(from, "events", nil)
                for _, event := range eventsMap </span><span class="cov0" title="0">{
                        events = append(events, event)
                }</span>
        }

        <span class="cov0" title="0">eventProps := make([]*TrackingPlanEventArgs, len(events))
        for idx, event := range events </span><span class="cov0" title="0">{
                event := event.(map[string]interface{})

                eventProps[idx] = &amp;TrackingPlanEventArgs{
                        Name:            MustString(event, "name"),
                        Description:     MustString(event, "description"),
                        LocalID:         MustString(event, "localId"),
                        Type:            MustString(event, "type"),
                        AllowUnplanned:  MustBool(event, "allowUnplanned"),
                        IdentitySection: String(event, "identitySection", ""),
                        Properties:      make([]*TrackingPlanPropertyArgs, 0),
                }

                // Same situation as the events
                properties := InterfaceSlice(event, "properties", nil)
                if len(properties) == 0 </span><span class="cov0" title="0">{
                        propertiesMap := MapStringInterfaceSlice(event, "properties", nil)
                        for _, prop := range propertiesMap </span><span class="cov0" title="0">{
                                properties = append(properties, prop)
                        }</span>
                }

                <span class="cov0" title="0">tpProperties := make([]*TrackingPlanPropertyArgs, len(properties))
                for idx, property := range properties </span><span class="cov0" title="0">{
                        property := property.(map[string]interface{})
                        tpProperties[idx] = &amp;TrackingPlanPropertyArgs{
                                LocalID:          MustString(property, "localId"),
                                Name:             MustString(property, "name"),
                                Description:      MustString(property, "description"),
                                Type:             property["type"],
                                Config:           MapStringInterface(property, "config", make(map[string]interface{})),
                                Required:         MustBool(property, "required"),
                                HasCustomTypeRef: Bool(property, "hasCustomTypeRef", false),
                                HasItemTypesRef:  Bool(property, "hasItemTypesRef", false),
                        }
                }</span>
                <span class="cov0" title="0">eventProps[idx].Properties = tpProperties</span>
        }
        <span class="cov0" title="0">args.Events = eventProps</span>
}

func (args *TrackingPlanArgs) ToResourceData() resources.ResourceData <span class="cov0" title="0">{

        events := make([]map[string]interface{}, 0)
        for _, event := range args.Events </span><span class="cov0" title="0">{

                properties := make([]map[string]interface{}, 0)
                for _, property := range event.Properties </span><span class="cov0" title="0">{
                        properties = append(properties, map[string]interface{}{
                                "name":             property.Name,
                                "description":      property.Description,
                                "localId":          property.LocalID,
                                "type":             property.Type,
                                "config":           property.Config,
                                "required":         property.Required,
                                "hasCustomTypeRef": property.HasCustomTypeRef,
                                "hasItemTypesRef":  property.HasItemTypesRef,
                        })
                }</span>

                <span class="cov0" title="0">events = append(events, map[string]interface{}{
                        "localId":         event.LocalID,
                        "name":            event.Name,
                        "description":     event.Description,
                        "type":            event.Type,
                        "allowUnplanned":  event.AllowUnplanned,
                        "identitySection": event.IdentitySection,
                        "properties":      properties,
                })</span>
        }

        <span class="cov0" title="0">return resources.ResourceData{
                "name":        args.Name,
                "description": args.Description,
                "localId":     args.LocalID,
                "events":      events,
        }</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package state

func StringPtr(from map[string]interface{}, key string, defaultval *string) *string <span class="cov8" title="1">{
        return SafeMapValue(from, key, defaultval)
}</span>

func MustStringPtr(from map[string]any, key string) *string <span class="cov8" title="1">{
        return MustMapValue[string, any, *string](from, key)
}</span>

func String(from map[string]interface{}, key string, defaultval string) string <span class="cov8" title="1">{
        return SafeMapValue(from, key, defaultval)
}</span>

func MustString(from map[string]interface{}, key string) string <span class="cov8" title="1">{
        return MustMapValue[string, interface{}, string](from, key)
}</span>

func Int(from map[string]interface{}, key string, defaultval int) int <span class="cov0" title="0">{
        return SafeMapValue(from, key, defaultval)
}</span>

func MustInt(from map[string]interface{}, key string) int <span class="cov0" title="0">{
        return MustMapValue[string, interface{}, int](from, key)
}</span>

func Float64(from map[string]interface{}, key string, defaultval float64) float64 <span class="cov0" title="0">{
        return SafeMapValue(from, key, defaultval)
}</span>

func MustFloat64(from map[string]interface{}, key string) float64 <span class="cov0" title="0">{
        return MustMapValue[string, interface{}, float64](from, key)
}</span>

func Bool(from map[string]interface{}, key string, defaultval bool) bool <span class="cov8" title="1">{
        return SafeMapValue(from, key, defaultval)
}</span>

func MustBool(from map[string]interface{}, key string) bool <span class="cov8" title="1">{
        return MustMapValue[string, interface{}, bool](from, key)
}</span>

func MapStringInterface(from map[string]interface{}, key string, defaultval map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        return SafeMapValue(from, key, defaultval)
}</span>

func MapStringInterfacePtr(from map[string]interface{}, key string, defaultval *map[string]interface{}) *map[string]interface{} <span class="cov0" title="0">{
        return SafeMapValue(from, key, defaultval)
}</span>

func MustMapStringInterface(from map[string]interface{}, key string) map[string]interface{} <span class="cov8" title="1">{
        return MustMapValue[string, interface{}, map[string]interface{}](from, key)
}</span>

func MustMapStringInterfacePtr(from map[string]interface{}, key string) *map[string]interface{} <span class="cov0" title="0">{
        return MustMapValue[string, interface{}, *map[string]interface{}](from, key)
}</span>

func InterfaceSlice(from map[string]interface{}, key string, defaultval []interface{}) []interface{} <span class="cov8" title="1">{
        return SafeMapValue(from, key, defaultval)
}</span>

func MapStringInterfaceSlice(from map[string]interface{}, key string, defaultval []map[string]interface{}) []map[string]interface{} <span class="cov8" title="1">{
        return SafeMapValue(from, key, defaultval)
}</span>

func MustStringSlice(from map[string]interface{}, key string) []string <span class="cov0" title="0">{
        items := InterfaceSlice(from, key, nil)
        result := make([]string, len(items))
        for i, v := range items </span><span class="cov0" title="0">{
                result[i] = v.(string)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func SafeMapValue[K comparable, T any, V any](from map[K]T, key K, defaultval V) V <span class="cov8" title="1">{
        if val, ok := from[key]; ok </span><span class="cov8" title="1">{
                if v, ok := any(val).(V); ok </span><span class="cov8" title="1">{
                        return v
                }</span>
        }
        <span class="cov8" title="1">return defaultval</span>
}

func MustMapValue[K comparable, T any, V any](from map[K]T, key K) V <span class="cov8" title="1">{
        return any(from[key]).(V)
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package factory

import (
        "time"

        "github.com/google/uuid"
        "github.com/rudderlabs/rudder-iac/api/client/catalog"
)

type TrackingPlanCatalogFactory struct {
        trackingplan catalog.TrackingPlan
}

func NewTrackingPlanCatalogFactory() *TrackingPlanCatalogFactory <span class="cov0" title="0">{

        tp := catalog.TrackingPlan{
                ID:           uuid.New().String(),
                Name:         "default-tracking-plan",
                Version:      1,
                CreationType: "backend",
                WorkspaceID:  "workspace-id",
                CreatedAt:    time.Date(2021, 9, 1, 0, 0, 0, 0, time.UTC),
                UpdatedAt:    time.Date(2021, 9, 2, 0, 0, 0, 0, time.UTC),
                Description:  strptr("default-tracking-plan-description"),
                Events:       nil,
        }
        return &amp;TrackingPlanCatalogFactory{
                trackingplan: tp,
        }
}</span>

func (f *TrackingPlanCatalogFactory) WithID(id string) *TrackingPlanCatalogFactory <span class="cov0" title="0">{
        f.trackingplan.ID = id
        return f
}</span>

func (f *TrackingPlanCatalogFactory) WithName(name string) *TrackingPlanCatalogFactory <span class="cov0" title="0">{
        f.trackingplan.Name = name
        return f
}</span>

func (f *TrackingPlanCatalogFactory) WithDescription(description string) *TrackingPlanCatalogFactory <span class="cov0" title="0">{
        f.trackingplan.Description = strptr(description)
        return f
}</span>

func (f *TrackingPlanCatalogFactory) WithWorkspaceID(workspaceID string) *TrackingPlanCatalogFactory <span class="cov0" title="0">{
        f.trackingplan.WorkspaceID = workspaceID
        return f
}</span>

func (f *TrackingPlanCatalogFactory) WithCreationType(creationType string) *TrackingPlanCatalogFactory <span class="cov0" title="0">{
        f.trackingplan.CreationType = creationType
        return f
}</span>

func (f *TrackingPlanCatalogFactory) WithCreatedAt(createdAt time.Time) *TrackingPlanCatalogFactory <span class="cov0" title="0">{
        f.trackingplan.CreatedAt = createdAt
        return f
}</span>

func (f *TrackingPlanCatalogFactory) WithUpdatedAt(updatedAt time.Time) *TrackingPlanCatalogFactory <span class="cov0" title="0">{
        f.trackingplan.UpdatedAt = updatedAt
        return f
}</span>

func (f *TrackingPlanCatalogFactory) WithVersion(version int) *TrackingPlanCatalogFactory <span class="cov0" title="0">{
        f.trackingplan.Version = version
        return f
}</span>

func (f *TrackingPlanCatalogFactory) WithEvent(event catalog.TrackingPlanEvent) *TrackingPlanCatalogFactory <span class="cov0" title="0">{
        if f.trackingplan.Events == nil </span><span class="cov0" title="0">{
                f.trackingplan.Events = make([]catalog.TrackingPlanEvent, 0)
        }</span>
        <span class="cov0" title="0">f.trackingplan.Events = append(f.trackingplan.Events, event)
        return f</span>
}

func (f *TrackingPlanCatalogFactory) Build() catalog.TrackingPlan <span class="cov0" title="0">{
        return f.trackingplan
}</span>

func strptr(s string) *string <span class="cov0" title="0">{
        return &amp;s
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package factory

import (
        "github.com/google/uuid"
        "github.com/rudderlabs/rudder-iac/cli/pkg/provider/state"
)

type TrackingPlanArgsFactory struct {
        trackingplanArgs state.TrackingPlanArgs
}

func NewTrackingPlanArgsFactory() *TrackingPlanArgsFactory <span class="cov0" title="0">{

        args := state.TrackingPlanArgs{
                Name:        "tracking-plan-name",
                Description: "tracking-plan-description",
                LocalID:     uuid.New().String(),
                Events:      nil,
        }

        return &amp;TrackingPlanArgsFactory{
                trackingplanArgs: args,
        }
}</span>

func (f *TrackingPlanArgsFactory) WithName(name string) *TrackingPlanArgsFactory <span class="cov0" title="0">{
        f.trackingplanArgs.Name = name
        return f
}</span>

func (f *TrackingPlanArgsFactory) WithDescription(description string) *TrackingPlanArgsFactory <span class="cov0" title="0">{
        f.trackingplanArgs.Description = description
        return f
}</span>

func (f *TrackingPlanArgsFactory) WithLocalID(localID string) *TrackingPlanArgsFactory <span class="cov0" title="0">{
        f.trackingplanArgs.LocalID = localID
        return f
}</span>

func (f *TrackingPlanArgsFactory) WithEvent(event *state.TrackingPlanEventArgs) *TrackingPlanArgsFactory <span class="cov0" title="0">{
        if f.trackingplanArgs.Events == nil </span><span class="cov0" title="0">{
                f.trackingplanArgs.Events = make([]*state.TrackingPlanEventArgs, 0)
        }</span>

        <span class="cov0" title="0">f.trackingplanArgs.Events = append(f.trackingplanArgs.Events, event)
        return f</span>
}

func (f *TrackingPlanArgsFactory) Build() state.TrackingPlanArgs <span class="cov0" title="0">{
        return f.trackingplanArgs
}</span>

// ----------------------------------------------------------

type TrackingPlanStateFactory struct {
        trackingplanState state.TrackingPlanState
}

func NewTrackingPlanStateFactory() *TrackingPlanStateFactory <span class="cov0" title="0">{

        state := state.TrackingPlanState{
                ID:           "tracking-plan-id",
                Name:         "tracking-plan-name",
                Description:  "tracking-plan-description",
                WorkspaceID:  "workspace-id",
                Version:      1,
                CreationType: "backend",
                CreatedAt:    "2021-09-01T00:00:00Z",
                UpdatedAt:    "2021-09-02T00:00:00Z",
                Events:       nil,
        }

        return &amp;TrackingPlanStateFactory{
                trackingplanState: state,
        }
}</span>

func (f *TrackingPlanStateFactory) WithID(id string) *TrackingPlanStateFactory <span class="cov0" title="0">{
        f.trackingplanState.ID = id
        return f
}</span>

func (f *TrackingPlanStateFactory) WithName(name string) *TrackingPlanStateFactory <span class="cov0" title="0">{
        f.trackingplanState.Name = name
        return f
}</span>

func (f *TrackingPlanStateFactory) WithDescription(description string) *TrackingPlanStateFactory <span class="cov0" title="0">{
        f.trackingplanState.Description = description
        return f
}</span>

func (f *TrackingPlanStateFactory) WithWorkspaceID(workspaceID string) *TrackingPlanStateFactory <span class="cov0" title="0">{
        f.trackingplanState.WorkspaceID = workspaceID
        return f
}</span>

func (f *TrackingPlanStateFactory) WithCreatedAt(createdAt string) *TrackingPlanStateFactory <span class="cov0" title="0">{
        f.trackingplanState.CreatedAt = createdAt
        return f
}</span>

func (f *TrackingPlanStateFactory) WithUpdatedAt(updatedAt string) *TrackingPlanStateFactory <span class="cov0" title="0">{
        f.trackingplanState.UpdatedAt = updatedAt
        return f
}</span>

func (f *TrackingPlanStateFactory) WithTrackingPlanArgs(args state.TrackingPlanArgs) *TrackingPlanStateFactory <span class="cov0" title="0">{
        f.trackingplanState.TrackingPlanArgs = args
        return f
}</span>

func (f *TrackingPlanStateFactory) WithEvent(event *state.TrackingPlanEventState) *TrackingPlanStateFactory <span class="cov0" title="0">{
        if f.trackingplanState.Events == nil </span><span class="cov0" title="0">{
                f.trackingplanState.Events = make([]*state.TrackingPlanEventState, 0)
        }</span>

        <span class="cov0" title="0">f.trackingplanState.Events = append(f.trackingplanState.Events, event)
        return f</span>
}

func (f *TrackingPlanStateFactory) Build() state.TrackingPlanState <span class="cov0" title="0">{
        return f.trackingplanState
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package provider

import (
        "context"
        "fmt"
        "strings"

        "github.com/rudderlabs/rudder-iac/api/client/catalog"
        "github.com/rudderlabs/rudder-iac/cli/internal/syncer/resources"
        "github.com/rudderlabs/rudder-iac/cli/pkg/logger"
        "github.com/rudderlabs/rudder-iac/cli/pkg/provider/state"
        "github.com/samber/lo"
)

type TrackingPlanProvider struct {
        client catalog.DataCatalog
        log    *logger.Logger
}

const (
        PropertiesIdentity    = "properties"
        TraitsIdentity        = "traits"
        ContextTraitsIdentity = "context.traits"
)

func NewTrackingPlanProvider(client catalog.DataCatalog) *TrackingPlanProvider <span class="cov8" title="1">{
        return &amp;TrackingPlanProvider{
                client: client,
                log: &amp;logger.Logger{
                        Logger: log.With("type", "trackingplan"),
                },
        }
}</span>

func (p *TrackingPlanProvider) Create(ctx context.Context, ID string, input resources.ResourceData) (*resources.ResourceData, error) <span class="cov8" title="1">{
        p.log.Debug("creating tracking plan", "id", ID)

        args := state.TrackingPlanArgs{}
        args.FromResourceData(input)

        created, err := p.client.CreateTrackingPlan(ctx, catalog.TrackingPlanCreate{
                Name:        args.Name,
                Description: args.Description,
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating tracking plan in catalog: %w", err)
        }</span>

        <span class="cov8" title="1">var (
                eventStates []*state.TrackingPlanEventState
        )

        for _, event := range args.Events </span><span class="cov8" title="1">{
                lastupserted, err := p.client.UpsertTrackingPlan(
                        ctx,
                        created.ID,
                        GetUpsertEvent(event),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("upserting event: %s tracking plan in catalog: %w", event.LocalID, err)
                }</span>

                <span class="cov8" title="1">lastEvent := lastupserted.Events[len(lastupserted.Events)-1]
                eventStates = append(eventStates, &amp;state.TrackingPlanEventState{
                        ID:      lastEvent.ID,
                        EventID: lastEvent.EventID,
                        LocalID: event.LocalID,
                })</span>
        }

        <span class="cov8" title="1">tpState := state.TrackingPlanState{
                TrackingPlanArgs: args,
                ID:               created.ID,
                Name:             created.Name,
                Version:          created.Version,
                CreationType:     created.CreationType,
                Description:      *created.Description,
                WorkspaceID:      created.WorkspaceID,
                CreatedAt:        created.CreatedAt.String(),
                UpdatedAt:        created.UpdatedAt.String(),
                Events:           eventStates,
        }

        resourceData := tpState.ToResourceData()
        return &amp;resourceData, nil</span>

}

func (p *TrackingPlanProvider) Update(ctx context.Context, ID string, input resources.ResourceData, olds resources.ResourceData) (*resources.ResourceData, error) <span class="cov8" title="1">{
        p.log.Debug("updating tracking plan", "id", ID)

        prevState := state.TrackingPlanState{}
        prevState.FromResourceData(olds)

        toArgs := state.TrackingPlanArgs{}
        toArgs.FromResourceData(input)

        var (
                updated            *catalog.TrackingPlan
                err                error
                updatedEventStates = make([]*state.TrackingPlanEventState, 0)
        )

        // Start with the previous event states
        updatedEventStates = append(updatedEventStates, prevState.Events...)
        if prevState.TrackingPlanArgs.Name != toArgs.Name || prevState.TrackingPlanArgs.Description != toArgs.Description </span><span class="cov8" title="1">{
                if updated, err = p.client.UpdateTrackingPlan(
                        ctx,
                        prevState.ID,
                        toArgs.Name,
                        toArgs.Description); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("updating tracking plan in catalog: %w", err)
                }</span>
        }

        <span class="cov8" title="1">diff := prevState.Diff(toArgs)

        var deletedEvents []string
        for _, event := range diff.Deleted </span><span class="cov8" title="1">{

                upstreamEvent := prevState.EventByLocalID(event.LocalID)
                if upstreamEvent == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("state discrepancy as upstream event not found for local id: %s", event.LocalID)
                }</span>

                <span class="cov8" title="1">if err := p.client.DeleteTrackingPlanEvent(ctx, prevState.ID, upstreamEvent.EventID); err != nil &amp;&amp; !catalog.IsCatalogNotFoundError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("deleting tracking plan event in catalog: %w", err)
                }</span>

                // capture the catalogeventID which are unique as
                // the newly created events can have same localID
                <span class="cov8" title="1">deletedEvents = append(deletedEvents, upstreamEvent.ID)</span>
        }

        <span class="cov8" title="1">for _, event := range diff.Added </span><span class="cov8" title="1">{
                updated, err = p.client.UpsertTrackingPlan(
                        ctx,
                        prevState.ID,
                        GetUpsertEvent(event),
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("upserting event: %s tracking plan in catalog: %w", event.LocalID, err)
                }</span>

                <span class="cov8" title="1">updatedEventStates = append(updatedEventStates, &amp;state.TrackingPlanEventState{
                        ID:      updated.Events[len(updated.Events)-1].ID,
                        EventID: updated.Events[len(updated.Events)-1].EventID,
                        LocalID: event.LocalID,
                })</span>
        }

        <span class="cov8" title="1">for _, event := range diff.Updated </span><span class="cov0" title="0">{
                updated, err = p.client.UpsertTrackingPlan(
                        ctx,
                        prevState.ID,
                        GetUpsertEvent(event),
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("upserting event: %s tracking plan in catalog: %w", event.LocalID, err)
                }</span>

        }

        // filter the deleted events in it.
        <span class="cov8" title="1">updatedEventStates = lo.Filter(updatedEventStates, func(event *state.TrackingPlanEventState, idx int) bool </span><span class="cov8" title="1">{
                return !lo.Contains(deletedEvents, event.ID)
        }</span>)

        <span class="cov8" title="1">var tpState state.TrackingPlanState

        if updated == nil </span><span class="cov0" title="0">{
                // Copy from previous if anything isn't getting updated so we don't panic
                tpState = state.TrackingPlanState{
                        TrackingPlanArgs: toArgs,
                        ID:               prevState.ID,
                        Name:             prevState.Name,
                        Description:      prevState.Description,
                        CreationType:     prevState.CreationType,
                        Version:          prevState.Version,
                        WorkspaceID:      prevState.WorkspaceID,
                        CreatedAt:        prevState.CreatedAt,
                        UpdatedAt:        prevState.UpdatedAt,
                        Events:           prevState.Events,
                }
        }</span> else<span class="cov8" title="1"> {
                tpState = state.TrackingPlanState{
                        TrackingPlanArgs: toArgs,
                        ID:               updated.ID,
                        Name:             updated.Name,
                        Description:      *updated.Description,
                        CreationType:     updated.CreationType,
                        Version:          updated.Version,
                        WorkspaceID:      updated.WorkspaceID,
                        CreatedAt:        updated.CreatedAt.String(),
                        UpdatedAt:        updated.UpdatedAt.String(),
                        Events:           updatedEventStates,
                }
        }</span>

        <span class="cov8" title="1">resourceData := tpState.ToResourceData()
        return &amp;resourceData, nil</span>
}

func (p *TrackingPlanProvider) Delete(ctx context.Context, ID string, state resources.ResourceData) error <span class="cov8" title="1">{
        p.log.Debug("deleting tracking plan", "id", ID)

        if err := p.client.DeleteTrackingPlan(ctx, state["id"].(string)); err != nil &amp;&amp; !catalog.IsCatalogNotFoundError(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("deleting tracking plan in catalog: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func GetUpsertEvent(from *state.TrackingPlanEventArgs) catalog.TrackingPlanUpsertEvent <span class="cov8" title="1">{
        // Get the properties in correct shape before we can
        // send it to the catalog
        var (
                requiredProps   = make([]string, 0)
                propLookup      = make(map[string]interface{})
                identitySection = from.IdentitySection
        )

        // If the identity section empty, default to properties
        if from.IdentitySection == "" </span><span class="cov8" title="1">{
                identitySection = PropertiesIdentity
        }</span>

        <span class="cov8" title="1">for _, prop := range from.Properties </span><span class="cov8" title="1">{
                propMap := make(map[string]any)

                // Handle Type field based on HasCustomTypeRef flag
                if prop.HasCustomTypeRef </span><span class="cov8" title="1">{
                        // This is a custom type reference, use $ref format
                        // The Type has been dereferenced by the syncer to the actual name
                        typValue := fmt.Sprint(prop.Type)
                        propMap["$ref"] = fmt.Sprintf("#/$defs/%s", typValue)
                }</span> else<span class="cov8" title="1"> {
                        // Regular type handling
                        typValue, ok := prop.Type.(string)
                        if !ok </span><span class="cov0" title="0">{
                                // If not a string but something else, convert to string
                                typValue = fmt.Sprint(prop.Type)
                        }</span>

                        <span class="cov8" title="1">typ := lo.Map(strings.Split(typValue, ","), func(t string, _ int) string </span><span class="cov8" title="1">{
                                return strings.TrimSpace(t)
                        }</span>)
                        <span class="cov8" title="1">propMap["type"] = typ</span>
                }

                <span class="cov8" title="1">for k, v := range prop.Config </span><span class="cov8" title="1">{
                        if k == "itemTypes" &amp;&amp; prop.HasItemTypesRef </span><span class="cov8" title="1">{
                                refValue := v.([]any)[0].(string)

                                propMap["items"] = map[string]any{
                                        "$ref": fmt.Sprintf("#/$defs/%s", refValue),
                                }
                        }</span> else<span class="cov8" title="1"> if k == "itemTypes" </span><span class="cov8" title="1">{
                                propMap["items"] = map[string]interface{}{
                                        "type": v,
                                }
                        }</span> else<span class="cov8" title="1"> {
                                // Other config fields
                                propMap[k] = v
                        }</span>
                }

                <span class="cov8" title="1">propLookup[prop.Name] = propMap

                if prop.Required </span><span class="cov8" title="1">{
                        requiredProps = append(requiredProps, prop.Name)
                }</span>
        }

        <span class="cov8" title="1">return catalog.TrackingPlanUpsertEvent{
                Name:            from.Name,
                Description:     from.Description,
                EventType:       from.Type,
                IdentitySection: identitySection,
                Rules: getRulesBasedonIdentity(identitySection, &amp;catalog.TrackingPlanUpsertEventProperties{
                        Type:                 "object",
                        AdditionalProperties: from.AllowUnplanned,
                        Required:             requiredProps,
                        Properties:           propLookup,
                }),
        }</span>
}

func getRulesBasedonIdentity(identity string, properties *catalog.TrackingPlanUpsertEventProperties) catalog.TrackingPlanUpsertEventRules <span class="cov8" title="1">{
        var (
                propertiesIdentity *catalog.TrackingPlanUpsertEventProperties
                traitsIdentity     *catalog.TrackingPlanUpsertEventProperties
                contextIdentity    *catalog.TrackingPlanUpsertEventContextTraitsIdentity
        )

        switch identity </span>{

        case PropertiesIdentity:<span class="cov8" title="1">
                propertiesIdentity = properties</span>

        case TraitsIdentity:<span class="cov0" title="0">
                traitsIdentity = properties</span>

        case ContextTraitsIdentity:<span class="cov0" title="0">
                contextIdentity = &amp;catalog.TrackingPlanUpsertEventContextTraitsIdentity{
                        Properties: struct {
                                Traits catalog.TrackingPlanUpsertEventProperties `json:"traits,omitempty"`
                        }{
                                Traits: *properties,
                        },
                }</span>

        default:<span class="cov0" title="0">
                propertiesIdentity = properties</span> // fallback to properties
        }

        <span class="cov8" title="1">return catalog.TrackingPlanUpsertEventRules{
                Type: "object",
                Properties: struct {
                        Properties *catalog.TrackingPlanUpsertEventProperties            `json:"properties,omitempty"`
                        Traits     *catalog.TrackingPlanUpsertEventProperties            `json:"traits,omitempty"`
                        Context    *catalog.TrackingPlanUpsertEventContextTraitsIdentity `json:"context,omitempty"`
                }{
                        Properties: propertiesIdentity,
                        Traits:     traitsIdentity,
                        Context:    contextIdentity,
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package client

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strconv"
        "time"

        "github.com/rudderlabs/rudder-iac/cli/pkg/schema/models"
)

// SchemaClient handles API communication for schema fetching
type SchemaClient struct {
        httpClient *http.Client
        baseURL    string
        apiToken   string
}

// NewSchemaClient creates a new schema API client
func NewSchemaClient(baseURL, apiToken string) *SchemaClient <span class="cov8" title="1">{
        return &amp;SchemaClient{
                httpClient: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
                baseURL:  baseURL,
                apiToken: apiToken,
        }
}</span>

// FetchAllSchemas fetches all schemas with pagination support
func (c *SchemaClient) FetchAllSchemas(writeKey string) ([]models.Schema, error) <span class="cov8" title="1">{
        var allSchemas []models.Schema
        page := 1

        for </span><span class="cov8" title="1">{
                schemas, hasNext, err := c.fetchSchemasPage(page, writeKey)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to fetch schemas page %d: %w", page, err)
                }</span>

                <span class="cov8" title="1">allSchemas = append(allSchemas, schemas...)

                if !hasNext </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">page++</span>
        }

        <span class="cov8" title="1">return allSchemas, nil</span>
}

// fetchSchemasPage fetches a single page of schemas
func (c *SchemaClient) fetchSchemasPage(page int, writeKey string) ([]models.Schema, bool, error) <span class="cov8" title="1">{
        // Build URL with query parameters
        u, err := url.Parse(c.baseURL + "/v2/schemas")
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, fmt.Errorf("invalid base URL: %w", err)
        }</span>

        <span class="cov8" title="1">query := u.Query()
        query.Set("page", strconv.Itoa(page))
        if writeKey != "" </span><span class="cov8" title="1">{
                query.Set("writeKey", writeKey)
        }</span>
        <span class="cov8" title="1">u.RawQuery = query.Encode()

        // Create request
        req, err := http.NewRequest("GET", u.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Add authorization header
        <span class="cov8" title="1">req.Header.Set("Authorization", "Bearer "+c.apiToken)
        req.Header.Set("Content-Type", "application/json")

        // Make request
        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Check status code
        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                body, _ := io.ReadAll(resp.Body)
                return nil, false, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        // Parse response
        <span class="cov8" title="1">var response models.SchemasResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;response); err != nil </span><span class="cov8" title="1">{
                return nil, false, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov8" title="1">return response.Results, response.HasNext, nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package utils

import (
        "encoding/json"
        "fmt"
        "os"

        "github.com/rudderlabs/rudder-iac/cli/internal/schema/models"
)

// ReadSchemasFile reads a schemas JSON file and returns the parsed structure
func ReadSchemasFile(filepath string) (*models.SchemasFile, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file %s: %w", filepath, err)
        }</span>

        <span class="cov0" title="0">var schemasFile models.SchemasFile
        if err := json.Unmarshal(data, &amp;schemasFile); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse JSON from %s: %w", filepath, err)
        }</span>

        <span class="cov0" title="0">return &amp;schemasFile, nil</span>
}

// WriteSchemasFile writes the schemas structure to a JSON file with proper formatting
func WriteSchemasFile(filepath string, schemasFile *models.SchemasFile, indent int) error <span class="cov0" title="0">{
        var data []byte
        var err error

        if indent &gt; 0 </span><span class="cov0" title="0">{
                indentStr := ""
                for i := 0; i &lt; indent; i++ </span><span class="cov0" title="0">{
                        indentStr += " "
                }</span>
                <span class="cov0" title="0">data, err = json.MarshalIndent(schemasFile, "", indentStr)</span>
        } else<span class="cov0" title="0"> {
                data, err = json.Marshal(schemasFile)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal JSON: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(filepath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write file %s: %w", filepath, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// WriteJSONFile writes data to a JSON file with proper indentation
func WriteJSONFile(filename string, data interface{}, indent int) error <span class="cov0" title="0">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        encoder := json.NewEncoder(file)
        if indent &gt; 0 </span><span class="cov0" title="0">{
                encoder.SetIndent("", fmt.Sprintf("%*s", indent, ""))
        }</span>

        <span class="cov0" title="0">if err := encoder.Encode(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode JSON: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// FileExists checks if a file exists
func FileExists(filepath string) bool <span class="cov0" title="0">{
        _, err := os.Stat(filepath)
        return !os.IsNotExist(err)
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package validate

import (
        "fmt"

        "github.com/rudderlabs/rudder-iac/cli/pkg/localcatalog"
        catalog "github.com/rudderlabs/rudder-iac/cli/pkg/localcatalog"
)

type DuplicateNameIDKeysValidator struct {
}

func (dv *DuplicateNameIDKeysValidator) Validate(dc *catalog.DataCatalog) []ValidationError <span class="cov8" title="1">{
        log.Info("validating duplicate name and id keys on the entities in catalog")

        var errors []ValidationError

        var (
                propName = make(map[string]*localcatalog.Property)
                propID   = make(map[string]*localcatalog.Property)
        )

        // Checking duplicate id and name keys in properties
        for group, props := range dc.Properties </span><span class="cov0" title="0">{
                for _, prop := range props </span><span class="cov0" title="0">{

                        if lookup, ok := propName[prop.Name]; ok </span><span class="cov0" title="0">{
                                // If name and type on the property are same, then it's a duplicate
                                if lookup.Type == prop.Type </span><span class="cov0" title="0">{
                                        errors = append(errors, ValidationError{
                                                error:     fmt.Errorf("duplicate name key %s", prop.Name),
                                                Reference: fmt.Sprintf("#/properties/%s/%s", group, prop.LocalID),
                                        })
                                }</span>
                        }

                        <span class="cov0" title="0">if _, ok := propID[prop.LocalID]; ok </span><span class="cov0" title="0">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("duplicate id key %s", prop.LocalID),
                                        Reference: fmt.Sprintf("#/properties/%s/%s", group, prop.LocalID),
                                })
                        }</span>

                        <span class="cov0" title="0">propName[prop.Name] = &amp;prop
                        propID[prop.LocalID] = &amp;prop</span>
                }
        }

        <span class="cov8" title="1">var (
                eventName = make(map[string]any)
                eventID   = make(map[string]any)
        )

        // Checking duplicate id and name keys in events
        for group, events := range dc.Events </span><span class="cov0" title="0">{
                for _, event := range events </span><span class="cov0" title="0">{

                        if event.Type != "track" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if _, ok := eventName[event.Name]; ok </span><span class="cov0" title="0">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("duplicate name key %s", event.Name),
                                        Reference: fmt.Sprintf("#/events/%s/%s", group, event.LocalID),
                                })
                        }</span>

                        <span class="cov0" title="0">if _, ok := eventID[event.LocalID]; ok </span><span class="cov0" title="0">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("duplicate id key %s", event.LocalID),
                                        Reference: fmt.Sprintf("#/events/%s/%s", group, event.LocalID),
                                })
                        }</span>

                        <span class="cov0" title="0">eventName[event.Name] = nil
                        eventID[event.LocalID] = nil</span>
                }
        }

        <span class="cov8" title="1">var (
                tpName   = make(map[string]any)
                tpID     = make(map[string]any)
                tpRuleID = make(map[string]any)
        )

        // Checking duplicate id and name keys of trackingplans
        for group, tp := range dc.TrackingPlans </span><span class="cov0" title="0">{
                if _, ok := tpName[tp.Name]; ok </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                error:     fmt.Errorf("duplicate name key %s", tp.Name),
                                Reference: fmt.Sprintf("#/tp/%s/%s", group, tp.LocalID),
                        })
                }</span>

                <span class="cov0" title="0">if _, ok := tpID[tp.LocalID]; ok </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                error:     fmt.Errorf("duplicate id key %s", tp.LocalID),
                                Reference: fmt.Sprintf("#/tp/%s/%s", group, tp.LocalID),
                        })
                }</span>

                <span class="cov0" title="0">tpName[tp.Name] = nil
                tpID[tp.LocalID] = nil

                for _, rule := range tp.Rules </span><span class="cov0" title="0">{
                        if _, ok := tpRuleID[rule.LocalID]; ok </span><span class="cov0" title="0">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("duplicate id key %s", rule.LocalID),
                                        Reference: fmt.Sprintf("#/tp/%s/%s", group, tp.LocalID),
                                })
                        }</span>

                        <span class="cov0" title="0">tpRuleID[rule.LocalID] = nil</span>
                }
        }

        <span class="cov8" title="1">var (
                customTypeName = make(map[string]any)
                customTypeID   = make(map[string]any)
        )

        // Checking duplicate id and name keys in custom types
        for group, customTypes := range dc.CustomTypes </span><span class="cov8" title="1">{
                for _, customType := range customTypes </span><span class="cov8" title="1">{
                        if _, ok := customTypeName[customType.Name]; ok </span><span class="cov8" title="1">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("duplicate name key %s in custom types", customType.Name),
                                        Reference: fmt.Sprintf("#/custom-types/%s/%s", group, customType.LocalID),
                                })
                        }</span>

                        <span class="cov8" title="1">if _, ok := customTypeID[customType.LocalID]; ok </span><span class="cov8" title="1">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("duplicate id key %s in custom types", customType.LocalID),
                                        Reference: fmt.Sprintf("#/custom-types/%s/%s", group, customType.LocalID),
                                })
                        }</span>

                        <span class="cov8" title="1">customTypeName[customType.Name] = nil
                        customTypeID[customType.LocalID] = nil</span>
                }
        }

        <span class="cov8" title="1">return errors</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package validate

import (
        "fmt"
        "strings"

        catalog "github.com/rudderlabs/rudder-iac/cli/pkg/localcatalog"
)

var errInvalidRefFormat = fmt.Errorf("invalid reference format")

// RefValidator checks the references in tracking plan to other
// events and properties in data catalog and verifies if the refs are valid
type RefValidator struct {
}

func (rv *RefValidator) Validate(dc *catalog.DataCatalog) []ValidationError <span class="cov8" title="1">{
        log.Info("validating references lookup in entities in the catalog")

        errs := make([]ValidationError, 0)

        // Validate tracking plan references
        for _, tp := range dc.TrackingPlans </span><span class="cov0" title="0">{
                for _, rule := range tp.Rules </span><span class="cov0" title="0">{
                        errs = append(
                                errs,
                                rv.handleRefs(rule, dc)...,
                        )
                }</span>
        }

        // Validate custom type references
        <span class="cov8" title="1">for group, customTypes := range dc.CustomTypes </span><span class="cov8" title="1">{
                for _, customType := range customTypes </span><span class="cov8" title="1">{
                        // Only object types with properties need validation
                        if customType.Type == "object" &amp;&amp; len(customType.Properties) &gt; 0 </span><span class="cov8" title="1">{
                                reference := fmt.Sprintf("#/custom-types/%s/%s", group, customType.LocalID)

                                for i, prop := range customType.Properties </span><span class="cov8" title="1">{

                                        // Validate property reference format
                                        matches := catalog.PropRegex.FindStringSubmatch(prop.Ref)
                                        if len(matches) != 3 </span><span class="cov8" title="1">{
                                                errs = append(errs, ValidationError{
                                                        Reference: reference,
                                                        error:     fmt.Errorf("property reference at index %d has invalid format. Should be '#/properties/&lt;group&gt;/&lt;id&gt;'", i),
                                                })
                                                continue</span>
                                        }

                                        // Validate property existence
                                        <span class="cov8" title="1">groupName, propID := matches[1], matches[2]
                                        if property := dc.Property(groupName, propID); property == nil </span><span class="cov8" title="1">{
                                                errs = append(errs, ValidationError{
                                                        Reference: reference,
                                                        error:     fmt.Errorf("property reference '%s' at index %d not found in catalog", prop.Ref, i),
                                                })
                                        }</span>
                                }
                        }
                }
        }

        // Validate property type custom type references
        <span class="cov8" title="1">for group, props := range dc.Properties </span><span class="cov8" title="1">{
                for _, prop := range props </span><span class="cov8" title="1">{
                        reference := fmt.Sprintf("#/properties/%s/%s", group, prop.LocalID)

                        // Check if the type field contains a custom type reference
                        if strings.HasPrefix(prop.Type, "#/custom-types/") </span><span class="cov8" title="1">{
                                matches := catalog.CustomTypeRegex.FindStringSubmatch(prop.Type)
                                if len(matches) != 3 </span><span class="cov8" title="1">{
                                        errs = append(errs, ValidationError{
                                                Reference: reference,
                                                error:     fmt.Errorf("custom type reference in type field has invalid format. Should be '#/custom-types/&lt;group&gt;/&lt;id&gt;'"),
                                        })
                                        continue</span>
                                }

                                // Validate custom type existence
                                <span class="cov8" title="1">customTypeGroup, customTypeID := matches[1], matches[2]
                                if customType := dc.CustomType(customTypeGroup, customTypeID); customType == nil </span><span class="cov8" title="1">{
                                        errs = append(errs, ValidationError{
                                                Reference: reference,
                                                error:     fmt.Errorf("custom type reference '%s' not found in catalog", prop.Type),
                                        })
                                }</span>
                        }

                        // Check for custom type references in itemTypes when property is of type array
                        <span class="cov8" title="1">if prop.Type == "array" &amp;&amp; prop.Config != nil </span><span class="cov8" title="1">{
                                if itemTypes, ok := prop.Config["itemTypes"]; ok </span><span class="cov8" title="1">{
                                        if itemTypesArray, ok := itemTypes.([]any); ok </span><span class="cov8" title="1">{
                                                for idx, itemType := range itemTypesArray </span><span class="cov8" title="1">{
                                                        itemTypeStr, ok := itemType.(string)
                                                        if !ok </span><span class="cov0" title="0">{
                                                                continue</span>
                                                        }

                                                        // Check if the item type is a custom type reference
                                                        <span class="cov8" title="1">if strings.HasPrefix(itemTypeStr, "#/custom-types/") </span><span class="cov8" title="1">{
                                                                matches := catalog.CustomTypeRegex.FindStringSubmatch(itemTypeStr)
                                                                if len(matches) != 3 </span><span class="cov8" title="1">{
                                                                        errs = append(errs, ValidationError{
                                                                                Reference: reference,
                                                                                error:     fmt.Errorf("custom type reference in itemTypes at idx: %d has invalid format. Should be '#/custom-types/&lt;group&gt;/&lt;id&gt;'", idx),
                                                                        })
                                                                        continue</span>
                                                                }

                                                                // Validate custom type existence
                                                                <span class="cov8" title="1">customTypeGroup, customTypeID := matches[1], matches[2]
                                                                if customType := dc.CustomType(customTypeGroup, customTypeID); customType == nil </span><span class="cov8" title="1">{
                                                                        errs = append(errs, ValidationError{
                                                                                Reference: reference,
                                                                                error:     fmt.Errorf("custom type reference '%s' in itemTypes at idx: %d not found in catalog", itemTypeStr, idx),
                                                                        })
                                                                }</span>
                                                        }
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return errs</span>
}

func (rv *RefValidator) handleRefs(rule *catalog.TPRule, fetcher catalog.CatalogResourceFetcher) []ValidationError <span class="cov0" title="0">{
        errs := make([]ValidationError, 0)

        if rule.Event != nil </span><span class="cov0" title="0">{
                matches := catalog.EventRegex.FindStringSubmatch(rule.Event.Ref)
                if len(matches) != 3 </span><span class="cov0" title="0">{
                        errs = append(errs, ValidationError{
                                Reference: rule.Event.Ref,
                                error:     errInvalidRefFormat,
                        })
                }</span> else<span class="cov0" title="0"> {
                        if event := fetcher.Event(matches[1], matches[2]); event == nil </span><span class="cov0" title="0">{
                                errs = append(errs, ValidationError{
                                        Reference: rule.Event.Ref,
                                        error:     fmt.Errorf("no event found from reference"),
                                })
                        }</span>
                }
        }
        <span class="cov0" title="0">if rule.Properties != nil </span><span class="cov0" title="0">{
                for _, prop := range rule.Properties </span><span class="cov0" title="0">{
                        matches := catalog.PropRegex.FindStringSubmatch(prop.Ref)
                        if len(matches) != 3 </span><span class="cov0" title="0">{
                                errs = append(errs, ValidationError{
                                        Reference: prop.Ref,
                                        error:     errInvalidRefFormat,
                                })
                        }</span> else<span class="cov0" title="0"> {
                                if property := fetcher.Property(matches[1], matches[2]); property == nil </span><span class="cov0" title="0">{
                                        errs = append(errs, ValidationError{
                                                Reference: prop.Ref,
                                                error:     fmt.Errorf("no property found from reference"),
                                        })
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">if rule.Includes != nil </span><span class="cov0" title="0">{
                matches := catalog.IncludeRegex.FindStringSubmatch(rule.Includes.Ref)
                if len(matches) != 3 </span><span class="cov0" title="0">{
                        errs = append(errs, ValidationError{
                                Reference: rule.Includes.Ref,
                                error:     errInvalidRefFormat,
                        })
                }</span> else<span class="cov0" title="0"> {
                        group, id := matches[1], matches[2]
                        if id == "*" </span><span class="cov0" title="0">{
                                _, ok := fetcher.TPEventRules(group)
                                if !ok </span><span class="cov0" title="0">{
                                        errs = append(errs, ValidationError{
                                                Reference: rule.Includes.Ref,
                                                error:     fmt.Errorf("no event rules found from reference"),
                                        })
                                }</span>
                        } else<span class="cov0" title="0"> {
                                eventRule := fetcher.TPEventRule(group, id)
                                if eventRule == nil </span><span class="cov0" title="0">{
                                        errs = append(errs, ValidationError{
                                                Reference: rule.Includes.Ref,
                                                error:     fmt.Errorf("no event rule found from reference"),
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return errs</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package validate

import (
        "fmt"
        "regexp"
        "slices"
        "strings"

        catalog "github.com/rudderlabs/rudder-iac/cli/pkg/localcatalog"
)

type RequiredKeysValidator struct {
}

var validTypes = []string{
        "string", "number", "integer", "boolean", "null", "array", "object",
}

var validFormatValues = []string{
        "datetime",
        "date",
        "time",
        "email",
        "uuid",
        "hostname",
        "ipv4",
        "ipv6",
}

// Regex for custom type name validation
var customTypeNameRegex = regexp.MustCompile(`^[A-Z][a-zA-Z0-9_-]{2,64}$`)

func (rk *RequiredKeysValidator) Validate(dc *catalog.DataCatalog) []ValidationError <span class="cov8" title="1">{
        log.Info("validating required keys on the entities in catalog")

        var errors []ValidationError

        for group, props := range dc.Properties </span><span class="cov8" title="1">{
                for _, prop := range props </span><span class="cov8" title="1">{
                        reference := fmt.Sprintf("#/properties/%s/%s", group, prop.LocalID)

                        if prop.Name == "" || prop.Type == "" || prop.LocalID == "" </span><span class="cov0" title="0">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("id, name and type fields on property are mandatory"),
                                        Reference: reference,
                                })
                        }</span>

                        <span class="cov8" title="1">if catalog.CustomTypeRegex.Match([]byte(prop.Type)) </span><span class="cov0" title="0">{
                                if prop.Config != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ValidationError{
                                                error:     fmt.Errorf("property config not allowed if the type matches custom-type"),
                                                Reference: reference,
                                        })
                                }</span>

                        }

                        // Validate array type properties with custom type references in itemTypes
                        <span class="cov8" title="1">if prop.Type == "array" &amp;&amp; prop.Config != nil </span><span class="cov8" title="1">{
                                if itemTypes, ok := prop.Config["itemTypes"]; ok </span><span class="cov8" title="1">{
                                        itemTypesArray, ok := itemTypes.([]any)
                                        if !ok </span><span class="cov8" title="1">{
                                                errors = append(errors, ValidationError{
                                                        error:     fmt.Errorf("itemTypes must be an array"),
                                                        Reference: reference,
                                                })
                                                continue</span>
                                        }

                                        <span class="cov8" title="1">for idx, itemType := range itemTypesArray </span><span class="cov8" title="1">{
                                                val, ok := itemType.(string)
                                                if !ok </span><span class="cov8" title="1">{
                                                        errors = append(errors, ValidationError{
                                                                error:     fmt.Errorf("itemTypes at idx: %d must be string value", idx),
                                                                Reference: reference,
                                                        })
                                                        continue</span>
                                                }

                                                <span class="cov8" title="1">if catalog.CustomTypeRegex.Match([]byte(val)) </span><span class="cov8" title="1">{
                                                        if len(itemTypesArray) != 1 </span><span class="cov8" title="1">{
                                                                errors = append(errors, ValidationError{
                                                                        error:     fmt.Errorf("itemTypes containing custom type at idx: %d cannot be paired with other types", idx),
                                                                        Reference: reference,
                                                                })
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        // Events required keys
        <span class="cov8" title="1">for group, events := range dc.Events </span><span class="cov0" title="0">{
                for _, event := range events </span><span class="cov0" title="0">{
                        reference := fmt.Sprintf("#/events/%s/%s", group, event.LocalID)

                        if event.LocalID == "" || event.Type == "" </span><span class="cov0" title="0">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("id and event_type fields on event are mandatory"),
                                        Reference: reference,
                                })
                        }</span>

                        <span class="cov0" title="0">if event.Type == "track" </span><span class="cov0" title="0">{
                                if event.Name == "" </span><span class="cov0" title="0">{
                                        errors = append(errors, ValidationError{
                                                error:     fmt.Errorf("name field is mandatory on track event"),
                                                Reference: reference,
                                        })
                                }</span>
                        }
                }
        }

        // Tracking Plan required keys
        <span class="cov8" title="1">for group, tp := range dc.TrackingPlans </span><span class="cov0" title="0">{

                if tp.Name == "" </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                error:     fmt.Errorf("name field is mandatory on the tracking plan"),
                                Reference: fmt.Sprintf("#/tp/%s/%s", group, tp.LocalID),
                        })
                }</span>

                <span class="cov0" title="0">for _, rule := range tp.Rules </span><span class="cov0" title="0">{
                        if rule.LocalID == "" </span><span class="cov0" title="0">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("id field is mandatory on the rules in tracking plan"),
                                        Reference: fmt.Sprintf("#/tp/%s/%s", group, tp.LocalID),
                                })
                        }</span>

                        <span class="cov0" title="0">if rule.Event == nil &amp;&amp; rule.Includes == nil </span><span class="cov0" title="0">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("event or includes section within the rules: %s in tracking plan are mandatory", rule.LocalID),
                                        Reference: fmt.Sprintf("#/tp/%s/%s", group, tp.LocalID),
                                })
                        }</span>

                        <span class="cov0" title="0">if rule.Event != nil &amp;&amp; rule.Includes != nil </span><span class="cov0" title="0">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("event and includes both section within the rules: %s in tracking plan are not allowed", rule.LocalID),
                                        Reference: fmt.Sprintf("#/tp/%s/%s", group, tp.LocalID),
                                })
                        }</span>

                        <span class="cov0" title="0">if rule.Event == nil &amp;&amp; len(rule.Properties) &gt; 0 </span><span class="cov0" title="0">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("properties without events in rule: %s are not allowed", rule.LocalID),
                                        Reference: fmt.Sprintf("#/tp/%s/%s", group, tp.LocalID),
                                })
                        }</span>

                }
        }

        // Custom Types required keys
        <span class="cov8" title="1">for group, customTypes := range dc.CustomTypes </span><span class="cov8" title="1">{
                for _, customType := range customTypes </span><span class="cov8" title="1">{
                        reference := fmt.Sprintf("#/custom-types/%s/%s", group, customType.LocalID)

                        // Check mandatory fields
                        if customType.LocalID == "" || customType.Name == "" || customType.Type == "" </span><span class="cov8" title="1">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("id, name and type fields on custom type are mandatory"),
                                        Reference: reference,
                                })
                                continue</span>
                        }

                        // Check each property in properties has id field
                        <span class="cov8" title="1">if customType.Type == "object" </span><span class="cov8" title="1">{

                                if len(customType.Config) &gt; 0 </span><span class="cov0" title="0">{
                                        errors = append(errors, ValidationError{
                                                error:     fmt.Errorf("config is not allowed on custom type of type object"),
                                                Reference: reference,
                                        })
                                }</span>

                                <span class="cov8" title="1">for i, prop := range customType.Properties </span><span class="cov8" title="1">{
                                        if prop.Ref == "" </span><span class="cov8" title="1">{
                                                errors = append(errors, ValidationError{
                                                        error:     fmt.Errorf("$ref field is mandatory for property at index %d in custom type", i),
                                                        Reference: reference,
                                                })
                                        }</span>
                                }
                        }

                        // Name format validation - no need to check if name is empty as we already checked above
                        <span class="cov8" title="1">if !customTypeNameRegex.MatchString(customType.Name) </span><span class="cov8" title="1">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("custom type name must start with a capital letter and contain only letters, numbers, underscores and dashes, and be between 2 and 65 characters long"),
                                        Reference: reference,
                                })
                        }</span>

                        // Type validation
                        <span class="cov8" title="1">if !slices.Contains(validTypes, customType.Type) </span><span class="cov8" title="1">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("invalid data type, acceptable values are: %s", strings.Join(validTypes, ", ")),
                                        Reference: reference,
                                })
                        }</span>

                        <span class="cov8" title="1">if customType.Config != nil </span><span class="cov8" title="1">{
                                switch customType.Type </span>{
                                case "string":<span class="cov8" title="1">
                                        errors = append(errors, rk.validateStringConfig(customType.Config, reference)...)</span>
                                case "number", "integer":<span class="cov8" title="1">
                                        errors = append(errors, rk.validateNumberConfig(customType.Config, reference, customType.Type)...)</span>
                                case "array":<span class="cov8" title="1">
                                        errors = append(errors, rk.validateArrayConfig(customType.Config, reference)...)</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return errors</span>
}

// validateStringConfig validates config fields for string type
func (rk *RequiredKeysValidator) validateStringConfig(config map[string]any, reference string) []ValidationError <span class="cov8" title="1">{
        var errors []ValidationError

        // Check enum is an array of strings
        if enum, ok := config["enum"]; ok </span><span class="cov0" title="0">{
                _, ok := enum.([]any)
                if !ok </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                error:     fmt.Errorf("enum must be an array"),
                                Reference: reference,
                        })
                }</span>
        }

        // Check minLength is a number
        <span class="cov8" title="1">if minLength, ok := config["minLength"]; ok </span><span class="cov8" title="1">{
                if !isInteger(minLength) </span><span class="cov8" title="1">{
                        errors = append(errors, ValidationError{
                                error:     fmt.Errorf("minLength must be a number"),
                                Reference: reference,
                        })
                }</span>
        }

        // Check maxLength is a number
        <span class="cov8" title="1">if maxLength, ok := config["maxLength"]; ok </span><span class="cov0" title="0">{
                if !isInteger(maxLength) </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                error:     fmt.Errorf("maxLength must be a number"),
                                Reference: reference,
                        })
                }</span>
        }

        // Check pattern is a string
        <span class="cov8" title="1">if pattern, ok := config["pattern"]; ok </span><span class="cov0" title="0">{
                if _, ok := pattern.(string); !ok </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                error:     fmt.Errorf("pattern must be a string"),
                                Reference: reference,
                        })
                }</span>
        }

        // Check format is a valid value
        <span class="cov8" title="1">if format, ok := config["format"]; ok </span><span class="cov0" title="0">{
                formatStr, ok := format.(string)
                if !ok </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                error:     fmt.Errorf("format must be a string"),
                                Reference: reference,
                        })
                }</span> else<span class="cov0" title="0"> if !slices.Contains(validFormatValues, formatStr) </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                error:     fmt.Errorf("invalid format value, acceptable values are %s", strings.Join(validFormatValues, ", ")),
                                Reference: reference,
                        })
                }</span>
        }

        <span class="cov8" title="1">return errors</span>
}

// validateNumberConfig validates config fields for number/integer type
func (rk *RequiredKeysValidator) validateNumberConfig(config map[string]any, reference string, ctType string) []ValidationError <span class="cov8" title="1">{

        var (
                errors    []ValidationError
                typeCheck func(val any) bool = isNumber
        )

        // integer custom type has a stricter
        // check for the same items within the config
        if ctType == "integer" </span><span class="cov0" title="0">{
                typeCheck = isInteger
        }</span>

        // Check enum is an array of numbers
        <span class="cov8" title="1">if enum, ok := config["enum"]; ok </span><span class="cov0" title="0">{
                enumArray, ok := enum.([]any)
                if !ok </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                error:     fmt.Errorf("enum must be an array"),
                                Reference: reference,
                        })
                }</span> else<span class="cov0" title="0"> {
                        for i, val := range enumArray </span><span class="cov0" title="0">{
                                if !typeCheck(val) </span><span class="cov0" title="0">{
                                        errors = append(errors, ValidationError{
                                                error:     fmt.Errorf("enum value at index %d must be a %s", i, ctType),
                                                Reference: reference,
                                        })
                                }</span>
                        }
                }
        }

        // Check numeric fields are numbers
        <span class="cov8" title="1">numericFields := []string{"minimum", "maximum", "exclusiveMinimum", "exclusiveMaximum", "multipleOf"}
        for _, field := range numericFields </span><span class="cov8" title="1">{
                if val, ok := config[field]; ok </span><span class="cov8" title="1">{
                        if !typeCheck(val) </span><span class="cov8" title="1">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("%s must be a %s", field, ctType),
                                        Reference: reference,
                                })
                        }</span>
                }
        }

        <span class="cov8" title="1">return errors</span>
}

// validateArrayConfig validates config fields for array type
func (rk *RequiredKeysValidator) validateArrayConfig(config map[string]any, reference string) []ValidationError <span class="cov8" title="1">{
        var errors []ValidationError

        // Check itemTypes is an array with a single item
        if itemTypes, ok := config["itemTypes"]; ok </span><span class="cov8" title="1">{
                itemTypesArray, ok := itemTypes.([]any)
                if !ok </span><span class="cov8" title="1">{
                        errors = append(errors, ValidationError{
                                error:     fmt.Errorf("itemTypes must be an array"),
                                Reference: reference,
                        })
                }</span>

                <span class="cov8" title="1">for idx, itemType := range itemTypesArray </span><span class="cov0" title="0">{
                        val, ok := itemType.(string)
                        if !ok </span><span class="cov0" title="0">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("itemTypes at idx: %d must be string value", idx),
                                        Reference: reference,
                                })

                                continue</span>
                        }

                        <span class="cov0" title="0">if catalog.CustomTypeRegex.Match([]byte(val)) </span><span class="cov0" title="0">{
                                if len(itemTypesArray) != 1 </span><span class="cov0" title="0">{
                                        errors = append(errors, ValidationError{
                                                error:     fmt.Errorf("itemTypes containing custom type at idx: %d cannot be paired with other types", idx),
                                                Reference: reference,
                                        })
                                }</span>

                                <span class="cov0" title="0">continue</span>
                        }

                        <span class="cov0" title="0">if !slices.Contains(validTypes, val) </span><span class="cov0" title="0">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("itemTypes at idx: %d is invalid, valid type values are: %s", idx, strings.Join(validTypes, ",")),
                                        Reference: reference,
                                })
                        }</span>

                }
        }

        // Check numeric fields are numbers
        <span class="cov8" title="1">numericFields := []string{"minItems", "maxItems"}
        for _, field := range numericFields </span><span class="cov8" title="1">{
                if val, ok := config[field]; ok </span><span class="cov0" title="0">{
                        if !isInteger(val) </span><span class="cov0" title="0">{
                                errors = append(errors, ValidationError{
                                        error:     fmt.Errorf("%s must be a number", field),
                                        Reference: reference,
                                })
                        }</span>
                }
        }

        // Check uniqueItems is a boolean
        <span class="cov8" title="1">if uniqueItems, ok := config["uniqueItems"]; ok </span><span class="cov0" title="0">{
                if _, ok := uniqueItems.(bool); !ok </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                error:     fmt.Errorf("uniqueItems must be a boolean"),
                                Reference: reference,
                        })
                }</span>
        }

        <span class="cov8" title="1">return errors</span>
}

func isNumber(val any) bool <span class="cov8" title="1">{
        switch val.(type) </span>{
        case int, int8, int16, int32, int64:<span class="cov8" title="1">
                return true</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov8" title="1">
                return true</span>
        case float32, float64:<span class="cov8" title="1">
                return true</span>
        }

        <span class="cov8" title="1">return false</span>
}

func isInteger(val any) bool <span class="cov8" title="1">{

        switch v := val.(type) </span>{
        case int, int8, int16, int32, int64:<span class="cov8" title="1">
                return true</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return true</span>
        case float32:<span class="cov8" title="1">
                return float32(int(v)) == v</span>
        case float64:<span class="cov8" title="1">
                return float64(int64(v)) == v</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package validate

import (
        "errors"
        "fmt"

        "github.com/rudderlabs/rudder-iac/cli/pkg/localcatalog"
        "github.com/rudderlabs/rudder-iac/cli/pkg/logger"
)

var log = logger.New("validate")

type ValidationError struct {
        error
        Reference string
}

type CatalogValidator interface {
        Validate(*localcatalog.DataCatalog) []ValidationError
}

func DefaultValidators() []CatalogValidator <span class="cov0" title="0">{
        return []CatalogValidator{
                &amp;RequiredKeysValidator{},
                &amp;DuplicateNameIDKeysValidator{},
                &amp;RefValidator{},
        }
}</span>

func ValidateCatalog(dc *localcatalog.DataCatalog) (toReturn error) <span class="cov0" title="0">{
        log.Info("running validators on the catalog")

        combinedErrs := make([]ValidationError, 0)
        validators := DefaultValidators()
        for _, validator := range validators </span><span class="cov0" title="0">{
                errs := validator.Validate(dc)
                if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                        combinedErrs = append(combinedErrs, errs...)
                }</span>
        }

        <span class="cov0" title="0">errStr := ""
        for _, err := range combinedErrs </span><span class="cov0" title="0">{
                errStr += fmt.Sprintf("\nreference: %s, error: %s\n\n", err.Reference, err.Error())
        }</span>

        <span class="cov0" title="0">if len(errStr) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return errors.New(errStr)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
