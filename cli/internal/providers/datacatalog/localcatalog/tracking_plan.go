package localcatalog

import (
	"encoding/json"
	"fmt"
	"regexp"

	"github.com/rudderlabs/rudder-iac/cli/internal/project/specs"
)

var (
	// Regex patterns support both old (#/kind/group/id) and new (#kind:id) formats
	// Non-capturing groups (?:...) ensure the we only capture the localId from the reference string
	PropRegex       = regexp.MustCompile(`^#(?:/properties/[^/]+/|property:)(.+)$`)
	EventRegex      = regexp.MustCompile(`^#(?:/events/[^/]+/|event:)(.+)$`)
	IncludeRegex    = regexp.MustCompile(`^#\/tp\/(.*)\/event_rule\/(.*)$`)
	CustomTypeRegex = regexp.MustCompile(`^#(?:/custom-types/[^/]+/|custom-type:)(.+)$`)
	CategoryRegex   = regexp.MustCompile(`^#(?:/categories/[^/]+/|category:)(.+)$`)
)

type CatalogResourceFetcher interface {
	Event(id string) *Event
	Property(id string) *PropertyV1
	Category(id string) *Category
	CustomType(id string) *CustomTypeV1
	TPEventRule(tpID, ruleID string) *TPRuleV1
	TPEventRules(tpID string) ([]*TPRuleV1, bool)
}

type TrackingPlan struct {
	Name        string    `json:"display_name"`
	LocalID     string    `json:"id"`
	Description string    `json:"description,omitempty"`
	Rules       []*TPRule `json:"rules,omitempty"`
	// Event and Props underneath event on the tracking plan
	// This is automatically generated by the code when expanding refs
	EventProps []*TPEvent `json:"event_props,omitempty"`
}

type TPEvent struct {
	Name            string
	LocalID         string
	Ref             string
	Description     string
	CategoryRef     *string
	Type            string
	AllowUnplanned  bool
	IdentitySection string
	Properties      []*TPEventProperty
	Variants        Variants
}

func (e *TPEvent) PropertyByLocalID(localID string) *TPEventProperty {
	for _, prop := range e.Properties {
		if prop.LocalID == localID {
			return prop
		}
	}
	return nil
}

type TPEventProperty struct {
	Name                 string                 `json:"name"`
	Ref                  string                 `json:"$ref"`
	LocalID              string                 `json:"id"`
	Description          string                 `json:"description"`
	Type                 string                 `json:"type"`
	Config               map[string]interface{} `json:"config"`
	Required             bool                   `json:"required"`
	Properties           []*TPEventProperty     `json:"properties,omitempty"` // NEW: Nested properties
	AdditionalProperties *bool                  `json:"additionalProperties,omitempty"`
}

type TPRule struct {
	Type       string            `json:"type"`
	LocalID    string            `json:"id"`
	Event      *TPRuleEvent      `json:"event"`
	Properties []*TPRuleProperty `json:"properties,omitempty"`
	Includes   *TPRuleIncludes   `json:"includes,omitempty"`
	Variants   Variants          `json:"variants,omitempty"`
}

type TPRuleEvent struct {
	Ref             string `json:"$ref"`
	AllowUnplanned  bool   `json:"allow_unplanned"`
	IdentitySection string `json:"identity_section"`
}

type TPRuleProperty struct {
	Ref                  string            `json:"$ref"`
	Required             bool              `json:"required"`
	AdditionalProperties *bool             `json:"additionalProperties,omitempty"`
	Properties           []*TPRuleProperty `json:"properties,omitempty"`
}

type TPRuleIncludes struct {
	Ref string `json:"$ref"`
}

// ExpandRefs simply expands the references being held
// when reading the tracking plan with the actual events and properties
func (tp *TrackingPlanV1) ExpandRefs(dc *DataCatalog) error {
	log.Debug("expanding refs for the tracking plan", "id", tp.LocalID)

	expandedEvents := make([]*TPEvent, 0)
	for _, rule := range tp.Rules {

		switch {
		case rule.Event != "":
			tpEvent, err := expandEventRefs(rule, dc)
			if err != nil {
				return fmt.Errorf("expanding event refs on the rule: %s in tracking plan: %s, err:%w",
					rule.LocalID,
					tp.LocalID,
					err)
			}
			expandedEvents = append(expandedEvents, tpEvent)

		case rule.Includes != nil:
			tpEvents, err := expandIncludeRefs(rule, dc)
			if err != nil {
				return fmt.Errorf("expanding include refs on the rule: %s in tracking plan: %s, err:%w",
					rule.LocalID,
					tp.LocalID,
					err)
			}
			expandedEvents = append(expandedEvents, tpEvents...)

		default:
			return fmt.Errorf("both the event and includes section in the rule:%s for tp: %s are nil", rule.LocalID, tp.LocalID)
		}

	}
	tp.EventProps = expandedEvents
	return nil
}

// expandIncludeRefs expands the include references in the tracking plan rule definition
// TODO: Make this function recursive to allow for multiple levels of include
func expandIncludeRefs(rule *TPRuleV1, fetcher CatalogResourceFetcher) ([]*TPEvent, error) {
	log.Debug("expanding include refs within the rule", "ruleID", rule.LocalID)

	if rule.Includes == nil {
		return nil, fmt.Errorf("empty rule includes")
	}

	matches := IncludeRegex.FindStringSubmatch(rule.Includes.Ref)
	if len(matches) != 3 {
		return nil, fmt.Errorf("includes ref: %s invalid as failed regex match", rule.Includes.Ref)
	}

	// ASK: how are we using include?
	// conventionally matches[1] would include the tpGroup and not the ID
	// we need to sort this out
	tpID, ruleID := matches[1], matches[2]
	rules := make([]*TPRuleV1, 0)

	if ruleID == "*" {
		eventRules, _ := fetcher.TPEventRules(tpID)
		rules = append(rules, eventRules...) // fetch all the tp rules
	} else {
		rules = append(rules, fetcher.TPEventRule(tpID, ruleID)) // fetch the specific rule
	}

	toReturn := make([]*TPEvent, 0)
	// Assume rules are now actual rules and not indirections
	for _, rule := range rules {

		if rule.Event == "" {
			continue
		}

		// This rule should have event ref only
		// which we can expand now
		event, err := expandEventRefs(rule, fetcher)
		if err != nil {
			return nil, fmt.Errorf("expanding event ref of the expanded include rule: %s failed, err: %w", rule.LocalID, err)
		}

		toReturn = append(toReturn, event)
	}

	return toReturn, nil
}

// expandEventRefs expands the direct event references in the tracking plan rule definition
func expandEventRefs(rule *TPRuleV1, fetcher CatalogResourceFetcher) (*TPEvent, error) {
	log.Debug("expanding event refs within the rule", "ruleID", rule.LocalID)

	if rule.Event == "" {
		return nil, fmt.Errorf("empty rule event")
	}

	matches := EventRegex.FindStringSubmatch(rule.Event)
	if len(matches) != 2 {
		return nil, fmt.Errorf("event ref: %s invalid as failed regex match", rule.Event)
	}

	eventID := matches[1]
	event := fetcher.Event(eventID)
	if event == nil {
		return nil, fmt.Errorf("looking up event: %s failed", eventID)
	}

	var categoryRef *string
	if event.CategoryRef != nil {
		catMatches := CategoryRegex.FindStringSubmatch(*event.CategoryRef)
		if len(catMatches) != 2 {
			return nil, fmt.Errorf("category ref: %s invalid as failed regex match", *event.CategoryRef)
		}
		categoryRef = event.CategoryRef
	}

	toReturn := TPEvent{
		Name:            event.Name,
		LocalID:         event.LocalID,
		Ref:             rule.Event,
		Description:     event.Description,
		CategoryRef:     categoryRef,
		Type:            event.Type,
		AllowUnplanned:  rule.AdditionalProperties,
		IdentitySection: rule.IdentitySection,
		Properties:      make([]*TPEventProperty, 0),
		Variants:        rule.Variants,
	}

	// Load the properties from the data catalog (including nested properties)
	// into corresponding event on the tracking plan
	for _, prop := range rule.Properties {
		property, err := expandPropertyRefs(prop, fetcher)
		if err != nil {
			return nil, fmt.Errorf("expanding property refs within the property: %s failed, err: %w", prop.Property, err)
		}

		toReturn.Properties = append(toReturn.Properties, &TPEventProperty{
			Name:                 property.Name,
			Ref:                  prop.Property,
			LocalID:              property.LocalID,
			Properties:           property.Properties,
			Description:          property.Description,
			Type:                 property.Type,
			Required:             prop.Required,
			Config:               shallowCopy(property.Config),
			AdditionalProperties: property.AdditionalProperties,
		})
	}

	return &toReturn, nil
}

func expandPropertyRefs(prop *TPRulePropertyV1, fetcher CatalogResourceFetcher) (*TPEventProperty, error) {
	log.Debug("expanding property refs within the property", "propertyID", prop.Property)

	matches := PropRegex.FindStringSubmatch(prop.Property)
	if len(matches) != 2 {
		return nil, fmt.Errorf("property ref: %s invalid as failed regex match", prop.Property)
	}

	propertyID := matches[1]
	property := fetcher.Property(propertyID)
	if property == nil {
		return nil, fmt.Errorf("looking up property: %s failed", propertyID)
	}

	properties := make([]*TPEventProperty, 0)
	for _, nestedProp := range prop.Properties {
		nestedProp, err := expandPropertyRefs(nestedProp, fetcher)
		if err != nil {
			return nil, fmt.Errorf("expanding nested property refs within the property: %s failed, err: %w", prop.Property, err)
		}
		properties = append(properties, nestedProp)
	}

	return &TPEventProperty{
		Name:                 property.Name,
		Ref:                  prop.Property,
		Properties:           properties,
		LocalID:              property.LocalID,
		Description:          property.Description,
		Type:                 property.Type,
		Required:             prop.Required,
		Config:               shallowCopy(property.Config),
		AdditionalProperties: prop.AdditionalProperties,
	}, nil
}

func shallowCopy(input map[string]any) map[string]any {
	output := make(map[string]any, len(input))

	for k, v := range input {
		output[k] = v
	}

	return output
}

func ExtractTrackingPlan(s *specs.Spec) (TrackingPlan, error) {
	log.Debug("extracting tracking plan from resource definition", "metadata.name", s.Metadata["name"])

	// The spec is the tracking plan in its enterity
	tp := TrackingPlan{}

	byt, err := json.Marshal(s.Spec)
	if err != nil {
		return TrackingPlan{}, fmt.Errorf("marshalling the spec")
	}

	if err := strictUnmarshal(byt, &tp); err != nil {
		return TrackingPlan{}, fmt.Errorf("unmarshalling the spec into tracking plan: %w", err)
	}

	return tp, nil
}

// TrackingPlanV1 represents the V1 spec format for tracking plans
type TrackingPlanV1 struct {
	Name        string      `json:"display_name"`
	LocalID     string      `json:"id"`
	Description string      `json:"description,omitempty"`
	Rules       []*TPRuleV1 `json:"rules,omitempty"`
	EventProps  []*TPEvent  `json:"event_props,omitempty"`
}

// TPRulePropertyV1 represents the V1 spec format for tracking plan rule properties
type TPRulePropertyV1 struct {
	Property             string              `json:"property"`
	Required             bool                `json:"required"`
	AdditionalProperties *bool               `json:"additionalProperties,omitempty"`
	Properties           []*TPRulePropertyV1 `json:"properties,omitempty"`
}

// FromV0 converts a V0 TPRuleProperty to V1 format
func (p *TPRulePropertyV1) FromV0(v0 *TPRuleProperty) error {
	p.Property = v0.Ref
	p.Required = v0.Required
	p.AdditionalProperties = v0.AdditionalProperties

	// Convert nested properties recursively
	if len(v0.Properties) > 0 {
		p.Properties = make([]*TPRulePropertyV1, 0, len(v0.Properties))
		for _, v0Prop := range v0.Properties {
			v1Prop := &TPRulePropertyV1{}
			if err := v1Prop.FromV0(v0Prop); err != nil {
				return fmt.Errorf("converting nested property to v1: %w", err)
			}
			p.Properties = append(p.Properties, v1Prop)
		}
	}

	return nil
}

// TPRuleV1 represents the V1 spec format for tracking plan rules
type TPRuleV1 struct {
	Type                 string              `json:"type"`
	LocalID              string              `json:"id"`
	Event                string              `json:"event"` // Direct reference instead of object
	IdentitySection      string              `json:"identity_section,omitempty"`
	AdditionalProperties bool                `json:"additionalProperties,omitempty"`
	Properties           []*TPRulePropertyV1 `json:"properties,omitempty"`
	Includes             *TPRuleIncludes     `json:"includes,omitempty"`
	Variants             Variants            `json:"variants,omitempty"`
}

// FromV0 converts a V0 TPRule to V1 format
func (r *TPRuleV1) FromV0(v0 *TPRule) error {
	r.Type = v0.Type
	r.LocalID = v0.LocalID
	r.Includes = v0.Includes
	r.Variants = v0.Variants

	// Convert event from object to direct reference
	if v0.Event != nil {
		r.Event = v0.Event.Ref
		r.IdentitySection = v0.Event.IdentitySection
		r.AdditionalProperties = v0.Event.AllowUnplanned
	}

	// Convert properties from V0 to V1
	if len(v0.Properties) > 0 {
		r.Properties = make([]*TPRulePropertyV1, 0, len(v0.Properties))
		for _, v0Prop := range v0.Properties {
			v1Prop := &TPRulePropertyV1{}
			if err := v1Prop.FromV0(v0Prop); err != nil {
				return fmt.Errorf("converting property to v1: %w", err)
			}
			r.Properties = append(r.Properties, v1Prop)
		}
	}

	return nil
}

// FromV0 converts a V0 TrackingPlan to V1 format
func (tp *TrackingPlanV1) FromV0(v0 *TrackingPlan) error {
	tp.Name = v0.Name
	tp.LocalID = v0.LocalID
	tp.Description = v0.Description
	tp.EventProps = v0.EventProps

	// Convert all rules from V0 to V1
	if len(v0.Rules) > 0 {
		tp.Rules = make([]*TPRuleV1, 0, len(v0.Rules))
		for _, v0Rule := range v0.Rules {
			v1Rule := &TPRuleV1{}
			if err := v1Rule.FromV0(v0Rule); err != nil {
				return fmt.Errorf("converting rule %s to v1: %w", v0Rule.LocalID, err)
			}
			tp.Rules = append(tp.Rules, v1Rule)
		}
	}

	return nil
}
