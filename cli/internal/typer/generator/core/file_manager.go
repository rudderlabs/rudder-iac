package core

import (
	"fmt"
	"os"
	"path/filepath"
)

// FileManager is responsible for creating files and parent directories
// that will hold the code generated by the BindingsGenerator
type FileManager struct {
	outputDir string
}

// NewFileManager creates a new FileManager instance
func NewFileManager(outputDir string) (*FileManager, error) {
	if outputDir == "" {
		return nil, fmt.Errorf("output directory cannot be empty")
	}

	// Ensure the output directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return nil, fmt.Errorf("creating output directory %s: %w", outputDir, err)
	}

	return &FileManager{
		outputDir: outputDir,
	}, nil
}

// WriteFiles writes multiple files to the filesystem
// It creates parent directories as needed and handles file writing atomically
func (fm *FileManager) WriteFiles(files []File) error {
	if len(files) == 0 {
		return nil
	}

	for _, file := range files {
		if err := fm.WriteFile(file); err != nil {
			return fmt.Errorf("writing file %s: %w", file.Path, err)
		}
	}

	return nil
}

// WriteFile writes a single file to the filesystem
// It creates parent directories as needed and handles file writing atomically
func (fm *FileManager) WriteFile(file File) error {
	if file.Path == "" {
		return fmt.Errorf("file path cannot be empty")
	}

	// Construct the full file path
	fullPath := filepath.Join(fm.outputDir, file.Path)

	// Create parent directories if they don't exist
	parentDir := filepath.Dir(fullPath)
	if err := os.MkdirAll(parentDir, 0755); err != nil {
		return fmt.Errorf("creating parent directory %s: %w", parentDir, err)
	}

	// Write file atomically using a temporary file
	if err := fm.writeFileAtomically(fullPath, file.Content); err != nil {
		return fmt.Errorf("writing file content: %w", err)
	}

	return nil
}

// writeFileAtomically writes file content atomically using a temporary file
// This ensures that if the write fails, the original file is not corrupted
func (fm *FileManager) writeFileAtomically(path, content string) error {
	// Create a temporary file in the same directory
	dir := filepath.Dir(path)
	name := filepath.Base(path)

	tmpFile, err := os.CreateTemp(dir, name+".tmp")
	if err != nil {
		return fmt.Errorf("creating temporary file: %w", err)
	}
	defer func() {
		tmpFile.Close()
		// Clean up temp file if it still exists
		os.Remove(tmpFile.Name())
	}()

	// Write content to temporary file
	if _, err := tmpFile.WriteString(content); err != nil {
		return fmt.Errorf("writing to temporary file: %w", err)
	}

	// Close the temporary file before renaming
	if err := tmpFile.Close(); err != nil {
		return fmt.Errorf("closing temporary file: %w", err)
	}

	// Atomically rename the temporary file to the target file
	if err := os.Rename(tmpFile.Name(), path); err != nil {
		return fmt.Errorf("renaming temporary file to target: %w", err)
	}

	return nil
}

// GetOutputDir returns the output directory path
func (fm *FileManager) GetOutputDir() string {
	return fm.outputDir
}

// EnsureOutputDir ensures the output directory exists
func (fm *FileManager) EnsureOutputDir() error {
	return os.MkdirAll(fm.outputDir, 0755)
}
